# CSV+ tests
## Distributed under both the W3C Test Suite License[1] and the W3C 3-
## clause BSD License[2]. To contribute to a W3C Test Suite, see the
## policies and contribution forms [3]
##
## 1. http://www.w3.org/Consortium/Legal/2008/04-testsuite-license
## 2. http://www.w3.org/Consortium/Legal/2008/03-bsd-license
## 3. http://www.w3.org/2004/10/27-testcases
##
## Test types (for now)
## * CsvToJsonTest  - tests CSV evaluation to JSON
## * CsvToRdfTest   - tests CSV evaluation to RDF using graph isomorphism
## * CsvSparqlTest - tests CSV evaulation to RDF using SPARQL ASK query

@prefix : <manifest-rdf#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mf:   <http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#> .
@prefix csvt: <http://w3c.github.io/csvw/tests/vocab#> .

<manifest-rdf>  a mf:Manifest ;

  rdfs:label "CSVW RDF Tests";
  rdfs:comment "Tests transformation of CSV to RDF.";
  mf:entries (
    :test001 :test002 :test003 :test005 :test006 :test007 :test008 :test009 :test010 :test011
    :test012 :test013 :test014 :test015 :test016 :test017 :test018 :test019 :test020 :test021
    :test022 :test023 :test024 :test025 :test026 :test027 :test028 :test029 :test030 :test031
    :test032 :test033 :test034 :test035 :test036 :test037 :test038 :test039 :test040 :test041
    :test042 :test043 :test044 :test045 :test046 :test047 :test048 :test049 :test050 :test051
    :test052 :test054 :test055 :test056 :test057 :test058 :test059 :test060 :test061 :test062
    :test063 :test065 :test066 :test067 :test068 :test069 :test070 :test071 :test072 :test073
    :test075 :test076
  ) .

:test001 a csvt:ToRdfTest;
  mf:name "Simple table";
  rdfs:comment "The simplest possible table without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test001.csv>;
  mf:result <test001.ttl>;
  .

:test002 a csvt:ToRdfTest;
  mf:name "Quoted field";
  rdfs:comment "Table with one quoted field without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test002.csv>;
  mf:result <test002.ttl>;
  .

:test003 a csvt:ToRdfTest;
  mf:name "Surrounding spaces";
  rdfs:comment "Table with whitespace before and after every field without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test003.csv>;
  mf:result <test003.ttl>;
  .

:test005 a csvt:ToRdfTest;
  mf:name "Identifier references";
  rdfs:comment "A table with entity identifiers and references to other entities without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test005.csv>;
  mf:result <test005.ttl>;
  .

:test006 a csvt:ToRdfTest;
  mf:name "No identifiers";
  rdfs:comment "Records contain two entities with relationships which are duplicated without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test006.csv>;
  mf:result <test006.ttl>;
  .

:test007 a csvt:ToRdfTest;
  mf:name "Joined table with unique identifiers";
  rdfs:comment "Joined data with identified records without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test007.csv>;
  mf:result <test007.ttl>;
  .

:test008 a csvt:ToRdfTest;
  mf:name "Microsyntax - internal field separator";
  rdfs:comment "One field has comma-separated values without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test008.csv>;
  mf:result <test008.ttl>;
  .

:test009 a csvt:ToRdfTest;
  mf:name "Microsyntax - formatted time";
  rdfs:comment "Field with parseable human formatted time without metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test009.csv>;
  mf:result <test009.ttl>;
  .

:test010 a csvt:ToRdfTest;
  mf:name "Country-codes-and-names example";
  rdfs:comment "Country-codes-and-names example";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test010.csv>;
  mf:result <test010.ttl>;
  .

:test011 a csvt:ToRdfTest;
  mf:name "tree-ops example with metadata";
  rdfs:comment "tree-ops example with metadata. Processors should load metadata based on action URL.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test011/tree-ops.csv>;
  mf:result <test011/result.ttl>;
  csvt:implicit <test011/tree-ops.csv-metadata.json>;
  .

:test012 a csvt:ToRdfTest;
  mf:name "tree-ops example with directory metadata";
  rdfs:comment "tree-ops example with directory metadata. Processors should find directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test012/tree-ops.csv>;
  mf:result <test012/result.ttl>;
  csvt:implicit <test012/metadata.json>;
  .

:test013 a csvt:ToRdfTest;
  mf:name "tree-ops example from user metadata";
  rdfs:comment "tree-ops example from user metadata.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test013-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test013.ttl>;
  csvt:implicit <test013-user-metadata.json>;
  .

:test014 a csvt:ToRdfTest;
  mf:name "tree-ops example with linked metadata";
  rdfs:comment "tree-ops example with linked metadata. Processors load metadata from link header.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  mf:action <test014/tree-ops.csv>;
  mf:result <test014/result.ttl>;
  csvt:implicit <test014/linked-metadata.json>;
  .

:test015 a csvt:ToRdfTest;
  mf:name "tree-ops example with user and directory metadata";
  rdfs:comment "tree-ops example with user and directory metadata. Processors should find directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test015/user-metadata.json>;
  ];
  mf:action <test015/tree-ops.csv>;
  mf:result <test015/result.ttl>;
  csvt:implicit <test015/user-metadata.json>,
    <test015/metadata.json>;
  .

:test016 a csvt:ToRdfTest;
  mf:name "tree-ops example with linked and directory metadata";
  rdfs:comment "tree-ops example with linked and directory metadata. Processors should find link- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  mf:action <test016/tree-ops.csv>;
  mf:result <test016/result.ttl>;
  csvt:implicit <test016/linked-metadata.json>,
    <test016/metadata.json>;
  .

:test017 a csvt:ToRdfTest;
  mf:name "tree-ops example with file and directory metadata";
  rdfs:comment "tree-ops example with file and directory metadata. Processors should find file- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test017/tree-ops.csv>;
  mf:result <test017/result.ttl>;
  csvt:implicit <test017/tree-ops.csv-metadata.json>,
    <test017/metadata.json>;
  .

:test018 a csvt:ToRdfTest;
  mf:name "tree-ops example with user, file and directory metadata";
  rdfs:comment "tree-ops example with user, file and directory metadata. Processors should find user-, file- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test018/user-metadata.json>;
  ];
  mf:action <test018/tree-ops.csv>;
  mf:result <test018/result.ttl>;
  csvt:implicit <test018/user-metadata.json>,
    <test018/tree-ops.csv-metadata.json>,
    <test018/metadata.json>;
  .

:test019 a csvt:ToRdfTest;
  mf:name "no header";
  rdfs:comment "If a CSV+ file does not include a header line, this MUST be specified using the `header` parameter.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test019.ttl>;
  csvt:contentType "text/csv;header=absent";
  .

:test020 a csvt:ToRdfTest;
  mf:name "dialect: trim=start";
  rdfs:comment "If `trim` is `true` or "start" then whitespace from the start of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test020-metadata.json>;
  mf:result <test020.ttl>;
  csvt:implicit <test020.csv>;
  .

:test021 a csvt:ToRdfTest;
  mf:name "dialect: trim=end";
  rdfs:comment "If `trim` is `true` or "end" then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test021-metadata.json>;
  mf:result <test021.ttl>;
  csvt:implicit <test021.csv>;
  .

:test022 a csvt:ToRdfTest;
  mf:name "dialect: trim=true";
  rdfs:comment "If `trim` is `true` or "start" then whitespace from the start of values that are not enclosed MUST be removed from the value. If `trim` is `true` or "end" then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test022-metadata.json>;
  mf:result <test022.ttl>;
  csvt:implicit <test022.csv>;
  .

:test023 a csvt:ToRdfTest;
  mf:name "dialect: header=false";
  rdfs:comment "If `true`, sets the `header row count` flag to 1, and if `false` to 0, unless `headerRowCount` is provided, in which case the value provided for the `header` property is ignored.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test023-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test023.ttl>;
  csvt:implicit <test023-user-metadata.json>;
  .

:test024 a csvt:ToRdfTest;
  mf:name "dialect: header=false and headerRowCount=1";
  rdfs:comment "If `true`, sets the `header row count` flag to 1, and if `false` to 0, unless `headerRowCount` is provided, in which case the value provided for the `header` property is ignored.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test024-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test024.ttl>;
  csvt:implicit <test024-user-metadata.json>;
  .

:test025 a csvt:ToRdfTest;
  mf:name "dialect: header=false and skipRows=1";
  rdfs:comment "Ignore header uses column definitions from metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test025-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test025.ttl>;
  csvt:implicit <test025-user-metadata.json>;
  .

:test026 a csvt:ToRdfTest;
  mf:name "tree-ops example with directory metadata";
  rdfs:comment "tree-ops example with directory metadata. Processors should find directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test026/metadata.json>;
  mf:result <test026/result.ttl>;
  csvt:implicit <test026/tree-ops.csv>,
    <test026/metadata.json>;
  .

:test027 a csvt:ToRdfTest;
  mf:name "tree-ops minimal output";
  rdfs:comment "tree-ops example with metadata. Minimal output mode";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test027-user-metadata.json>;
    csvt:minimal true;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test027.ttl>;
  csvt:implicit <test027-user-metadata.json>;
  .

:test028 a csvt:ToRdfTest;
  mf:name "countries.csv example";
  rdfs:comment "countries.csv example with no metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <countries.csv>;
  mf:result <test028.ttl>;
  .

:test029 a csvt:ToRdfTest;
  mf:name "countries.csv minimal";
  rdfs:comment "countries.csv example with no metadata and minimal output";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <countries.csv>;
  mf:result <test029.ttl>;
  .

:test030 a csvt:ToRdfTest;
  mf:name "countries.json example";
  rdfs:comment "countries.json from metadata";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <countries.json>;
  mf:result <test030.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test031 a csvt:ToRdfTest;
  mf:name "countries.json example minimal output";
  rdfs:comment "countries.json from metadata minimal output";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <countries.json>;
  mf:result <test031.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test032 a csvt:ToRdfTest;
  mf:name "events-listing.csv example";
  rdfs:comment "events-listing example with file metadata, virtual columns and multiple subjects per row";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test032/metadata.json>;
  mf:result <test032/result.ttl>;
  csvt:implicit <test032/events-listing.csv>,
    <test032/metadata.json-metadata.json>;
  .

:test033 a csvt:ToRdfTest;
  mf:name "events-listing.csv minimal output";
  rdfs:comment "events-listing example with file metadata, virtual columns and multiple subjects per row; minimal output";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <test033/metadata.json>;
  mf:result <test033/result.ttl>;
  csvt:implicit <test033/events-listing.csv>,
    <test033/metadata.json-metadata.json>;
  .

:test034 a csvt:ToRdfTest;
  mf:name "roles example";
  rdfs:comment "Public Sector Roles example with referenced schemas";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test034/metadata.json>;
  mf:result <test034/result.ttl>;
  csvt:implicit <test034/senior-roles.csv>,
    <test034/junior-roles.csv>,
    <test034/gov.uk/data/organizations.csv>,
    <test034/gov.uk/data/professions.csv>,
    <test034/gov.uk/schema/junior-roles.json>,
    <test034/gov.uk/schema/senior-roles.json>,
    <test034/gov.uk/schema/organizations.json>,
    <test034/gov.uk/schema/professions.json>;
  .

:test035 a csvt:ToRdfTest;
  mf:name "roles minimal";
  rdfs:comment "Public Sector Roles example with referenced schemas; minimal output";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <test035/metadata.json>;
  mf:result <test035/result.ttl>;
  csvt:implicit <test035/senior-roles.csv>,
    <test035/junior-roles.csv>,
    <test035/gov.uk/data/organizations.csv>,
    <test035/gov.uk/data/professions.csv>,
    <test035/gov.uk/schema/junior-roles.json>,
    <test035/gov.uk/schema/senior-roles.json>,
    <test035/gov.uk/schema/organizations.json>,
    <test035/gov.uk/schema/professions.json>;
  .

:test036 a csvt:ToRdfTest;
  mf:name "tree-ops-ext example";
  rdfs:comment "tree-ops extended example";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test036/tree-ops-ext.csv>;
  mf:result <test036/result.ttl>;
  csvt:implicit <test036/tree-ops-ext.csv-metadata.json>;
  .

:test037 a csvt:ToRdfTest;
  mf:name "tree-ops-ext minimal";
  rdfs:comment "tree-ops extended example; minimal output";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <test037/tree-ops-ext.csv>;
  mf:result <test037/result.ttl>;
  csvt:implicit <test037/tree-ops-ext.csv-metadata.json>;
  .

:test038 a csvt:ToRdfTest;
  mf:name "inherited properties propagation";
  rdfs:comment "Setting inherited properties at different levels inherit to cell";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test038-metadata.json>;
  mf:result <test038.ttl>;
  csvt:implicit <test038.csv>;
  .

:test039 a csvt:ToRdfTest;
  mf:name "valid inherited properties";
  rdfs:comment "Different combinations of valid inherited properties";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test039-metadata.json>;
  mf:result <test039.ttl>;
  csvt:implicit <test039.csv>;
  .

:test040 a csvt:ToRdfTest;
  mf:name "invalid null";
  rdfs:comment "Metadata generates warning and uses default with invalid `null` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test040-metadata.json>;
  mf:result <test040.ttl>;
  csvt:implicit <test040.csv>;
  .

:test041 a csvt:ToRdfTest;
  mf:name "invalid lang";
  rdfs:comment "Metadata generates warning and uses default with invalid `lang` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test041-metadata.json>;
  mf:result <test041.ttl>;
  csvt:implicit <test041.csv>;
  .

:test042 a csvt:ToRdfTest;
  mf:name "invalid textDirection";
  rdfs:comment "Metadata generates warning and uses default with invalid `textDirection`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test042-metadata.json>;
  mf:result <test042.ttl>;
  csvt:implicit <test042.csv>;
  .

:test043 a csvt:ToRdfTest;
  mf:name "invalid separator";
  rdfs:comment "Metadata generates warning and uses default with invalid `separator`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test043-metadata.json>;
  mf:result <test043.ttl>;
  csvt:implicit <test043.csv>;
  .

:test044 a csvt:ToRdfTest;
  mf:name "invalid ordered";
  rdfs:comment "Metadata generates warning and uses default with invalid `ordered`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test044-metadata.json>;
  mf:result <test044.ttl>;
  csvt:implicit <test044.csv>;
  .

:test045 a csvt:ToRdfTest;
  mf:name "invalid default";
  rdfs:comment "Metadata generates warning and uses default with invalid `default`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test045-metadata.json>;
  mf:result <test045.ttl>;
  csvt:implicit <test045.csv>;
  .

:test046 a csvt:ToRdfTest;
  mf:name "invalid dataype";
  rdfs:comment "Metadata generates warning and uses default with invalid `dataype`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test046-metadata.json>;
  mf:result <test046.ttl>;
  csvt:implicit <test046.csv>;
  .

:test047 a csvt:ToRdfTest;
  mf:name "invalid aboutUrl";
  rdfs:comment "Metadata generates warning and uses default with invalid `aboutUrl`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test047-metadata.json>;
  mf:result <test047.ttl>;
  csvt:implicit <test047.csv>;
  .

:test048 a csvt:ToRdfTest;
  mf:name "invalid propertyUrl";
  rdfs:comment "Metadata generates warning and uses default with invalid `propertyUrl`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test048-metadata.json>;
  mf:result <test048.ttl>;
  csvt:implicit <test048.csv>;
  .

:test049 a csvt:ToRdfTest;
  mf:name "invalid valueUrl";
  rdfs:comment "Metadata generates warning and uses default with invalid `valueUrl`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test049-metadata.json>;
  mf:result <test049.ttl>;
  csvt:implicit <test049.csv>;
  .

:test050 a csvt:ToRdfTest;
  mf:name "dialect: delimiter";
  rdfs:comment "Recognizes tab-separated-values with appropriate `delimiter`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test050-metadata.json>;
  mf:result <test050.ttl>;
  csvt:implicit <tree-ops.tsv>;
  .

:test051 a csvt:ToRdfTest;
  mf:name "dialect: commentPrefix in header";
  rdfs:comment "Adds comments when found in `skipRows`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test051-metadata.json>;
  mf:result <test051.ttl>;
  csvt:implicit <test051.csv>;
  .

:test052 a csvt:ToRdfTest;
  mf:name "dialect: commentPrefix in rows";
  rdfs:comment "Adds comments when found in `content`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test052-metadata.json>;
  mf:result <test052.ttl>;
  csvt:implicit <test052.csv>;
  .

:test054 a csvt:ToRdfTest;
  mf:name "dialect: skipColumns";
  rdfs:comment "Ignores skipped columns";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test054-metadata.json>;
  mf:result <test054.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test055 a csvt:ToRdfTest;
  mf:name "dialect: skipBlankRows";
  rdfs:comment "Ignores rows in which all columns are empty";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test055-metadata.json>;
  mf:result <test055.ttl>;
  csvt:implicit <test055.csv>;
  .

:test056 a csvt:ToRdfTest;
  mf:name "dialect: skipInitialSpace";
  rdfs:comment "Equivalent to` trim="start"`";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test056-metadata.json>;
  mf:result <test056.ttl>;
  csvt:implicit <test056.csv>;
  .

:test057 a csvt:ToRdfTest;
  mf:name "dialect as URL reference";
  rdfs:comment "Loads a `dialect description` if referenced using a URL";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test057-metadata.json>;
  mf:result <test057.ttl>;
  csvt:implicit <test057.csv>,
    <test057-dialect.json>;
  .

:test058 a csvt:ToRdfTest;
  mf:name "table dialect vs tablegroup dialect";
  rdfs:comment "A dialect defined in a Table completely overrides that defined in a TableGroup";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test058-metadata.json>;
  mf:result <test058.ttl>;
  csvt:implicit <test058.csv>;
  .

:test059 a csvt:ToRdfTest;
  mf:name "dialect: invalid commentPrefix";
  rdfs:comment "Metadata generates warning and uses default with invalid `commentPrefix` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test059-metadata.json>;
  mf:result <test059.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test060 a csvt:ToRdfTest;
  mf:name "dialect: invalid delimiter";
  rdfs:comment "Metadata generates warning and uses default with invalid `delimiter` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test060-metadata.json>;
  mf:result <test060.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test061 a csvt:ToRdfTest;
  mf:name "dialect: invalid doubleQuote";
  rdfs:comment "Metadata generates warning and uses default with invalid `doubleQuote` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test061-metadata.json>;
  mf:result <test061.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test062 a csvt:ToRdfTest;
  mf:name "dialect: invalid encoding";
  rdfs:comment "Metadata generates warning and uses default with invalid `encoding` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test062-metadata.json>;
  mf:result <test062.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test063 a csvt:ToRdfTest;
  mf:name "dialect: invalid header";
  rdfs:comment "Metadata generates warning and uses default with invalid `header` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test063-metadata.json>;
  mf:result <test063.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test065 a csvt:ToRdfTest;
  mf:name "dialect: invalid headerRowCount";
  rdfs:comment "Metadata generates warning and uses default with invalid `headerRowCount` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test065-metadata.json>;
  mf:result <test065.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test066 a csvt:ToRdfTest;
  mf:name "dialect: invalid lineTerminators";
  rdfs:comment "Metadata generates warning and uses default with invalid `lineTerminators` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test066-metadata.json>;
  mf:result <test066.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test067 a csvt:ToRdfTest;
  mf:name "dialect: invalid quoteChar";
  rdfs:comment "Metadata generates warning and uses default with invalid `quoteChar` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test067-metadata.json>;
  mf:result <test067.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test068 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipBlankRows";
  rdfs:comment "Metadata generates warning and uses default with invalid `skipBlankRows` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test068-metadata.json>;
  mf:result <test068.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test069 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipColumns";
  rdfs:comment "Metadata generates warning and uses default with invalid `skipColumns` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test069-metadata.json>;
  mf:result <test069.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test070 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipInitialSpace";
  rdfs:comment "Metadata generates warning and uses default with invalid `skipInitialSpace` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test070-metadata.json>;
  mf:result <test070.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test071 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipRows";
  rdfs:comment "Metadata generates warning and uses default with invalid `skipRows` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test071-metadata.json>;
  mf:result <test071.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test072 a csvt:ToRdfTest;
  mf:name "dialect: invalid trim";
  rdfs:comment "Metadata generates warning and uses default with invalid `trim` value";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test072-metadata.json>;
  mf:result <test072.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test073 a csvt:ToRdfTest;
  mf:name "invalid @language";
  rdfs:comment "The value of `@language` MUST be a valid `BCP47` language code";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test073-metadata.json>;
  mf:result <test073.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test075 a csvt:ToRdfTest;
  mf:name "invalid tableGroup tableDirection";
  rdfs:comment "An atomic property that must have a single string value that is one of "rtl", "ltr" or "default".";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test075-metadata.json>;
  mf:result <test075.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test076 a csvt:ToRdfTest;
  mf:name "invalid table tableDirection";
  rdfs:comment "An atomic property that must have a single string value that is one of "rtl", "ltr" or "default".";
  csvt:approval csvt:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test076-metadata.json>;
  mf:result <test076.ttl>;
  csvt:implicit <tree-ops.csv>;
  .
