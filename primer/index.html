<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Tabular Data on the Web: A Primer</title>
    <script class="remove" src="../local-biblio.js"></script>
    <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script class="remove" src="../replace-ed-uris.js"></script>
    <script class="remove">
      var respecConfig = {
          localBiblio: localBibliography,
          specStatus: "ED",
          shortName: "csvw-primer",
          //publishDate:  "2014-03-27",
          //previousPublishDate: "2015-04-16",
          //previousMaturity: "WD",
          //previousURI: "http://www.w3.org/TR/2015/WD-tabular-metadata-20150416/",
          edDraftURI: "http://w3c.github.io/csvw/primer/",
          //testSuiteURI: "http://www.w3.org/2013/csvw/tests/",
          //implementationReportURI: "http://www.w3.org/2013/csvw/tests/reports/index.html",
          // lcEnd: "3000-01-01",
          //crEnd: "2015-10-30",
          editors: [{
            name: "Jeni Tennison",
            company: "Open Data Institute",
            companyURL: "http://theodi.org/",
            w3cid: "33715"
          }],
          wg: "CSV on the Web Working Group",
          wgURI: "http://www.w3.org/2013/csvw/",
          wgPublicList: "public-csv-wg",
          wgPatentURI: "http://www.w3.org/2004/01/pp-impl/68238/status",
          otherLinks: [{
            key: "Repository",
            data: [{
                value: "We are on Github",
                href: "https://github.com/w3c/csvw"
            }, {
                value: "File a bug",
                href: "https://github.com/w3c/csvw"
            }]
          }],
          inlineCSS: true,
          issueBase: "https://github.com/w3c/csvw/issues/",
          noIDLIn: true,
          noLegacyStyle: false,
          useExperimentalStyles: true
          };
    </script>
    <script class="remove">
    function escapeContent(doc, content) {
          var utils = require("core/utils");
    // perform transformations to make it render and prettier
      return utils.xmlEscape(content);
    }
    </script>
    <style>
      td, th { padding-left: 1em; padding-right: 1em; }
      tbody tr th { text-align: left; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        CSV is one of the most popular formats for publishing data on the web. It is concise, easy to understand by both humans and computers, and aligns nicely to the tabular nature of most data.
      </p>
      <p>
        But CSV is also a poor format for data. There is no mechanism within CSV to indicate the type of data in a particular column, or whether values in a particular column must be unique. It is therefore hard to validate and prone to errors such as missing values or mismatching formats.
      </p>
      <p>
        The <a href="http://www.w3.org/2013/csvw">CSV on the Web Working Group</a> has developed standard ways to express useful metadata about CSV files and other kinds of tabular data. This primer takes you through the ways in which these standards work together, covering:
      </p>
      <ul>
        <li>What we mean by "tabular data" and "CSV"</li>
        <li>Where files that provide metadata about CSV live</li>
        <li>How to create a schema to validate the content of a CSV file</li>
        <li>How to specify how a CSV file should be converted to RDF or JSON</li>
        <li>How to provide other documentation and metadata about a CSV file</li>
      </ul>
      <p>
        Where possible, this primer links back to the normative definitions of terms and properties in the standards. Nothing in this primer overrides those normative definitions.
      </p>
    </section>
    <section id="sotd">
      <p>
        The <a href="http://www.w3.org/2013/csvw">CSV on the Web Working Group</a> was <a href="http://www.w3.org/2013/05/lcsv-charter.html">chartered</a> to produce a recommendation "Access methods for CSV Metadata" as well as recommendations for "Metadata vocabulary for CSV data" and "Mapping mechanism to transforming CSV into various formats (e.g., RDF, JSON, or XML)". This non-normative document is a primer that describes how these standards work together for new readers. The normative standards are:
      </p>
      <ul>
        <li><a href="http://w3c.github.io/csvw/syntax/">Model for Tabular Data and Metadata on the Web</a></li>
        <li><a href="http://w3c.github.io/csvw/metadata/">Metadata Vocabulary for Tabular Data</a></li>
        <li><a href="http://w3c.github.io/csvw/csv2json/">Generating JSON from Tabular Data on the Web</a></li>
        <li><a href="http://w3c.github.io/csvw/csv2rdf/">Generating RDF from Tabular Data on the Web</a></li>
      </ul>
    </section>
    <section>
      <h1>Introduction</h1>
      <p>
        We'll begin with some basic concepts.
      </p>
      <section>
        <h2>What is tabular data and CSV?</h2>
        <p>
          Tabular data is any data that can be arranged in a table, like the one here:
        </p>
        <table>
          <tr><th></th><th>column 1</th><th>column 2</th><th>column 3</th></tr>
          <tr><th>row 1</th><td>cell in column 1 and row 1</td><td>cell in column 2 and row 1</td><td>cell in column 3 and row 1</td></tr>
          <tr><th>row 2</th><td>cell in column 1 and row 2</td><td>cell in column 2 and row 2</td><td>cell in column 3 and row 2</td></tr>
          <tr><th>row 3</th><td>cell in column 1 and row 3</td><td>cell in column 2 and row 3</td><td>cell in column 3 and row 3</td></tr>
        </table>
        <p>
          There are lots of syntaxes for expressing tabular data on the web. You can put it in HTML tables, pass it around as Excel spreadsheets, or store it in a SQL database.
        </p>
        <p>
          One easy way to pass around tabular data is as CSV: as comma-separated values. A CSV file writes each row on a separate line and each cell is separated from the next with a comma. The values of cells can be written with double quotes around them; this is necessary when a cell value contains a line break or a comma. So the tabular data above can be expressed in CSV as:
        </p>
        <pre class="example">
cell in column 1 and row 1,cell in column 2 and row 1,cell in column 3 and row 1
cell in column 1 and row 2,cell in column 2 and row 2,cell in column 3 and row 2
cell in column 1 and row 3,cell in column 2 and row 3,cell in column 3 and row 3
</pre>
        <p>
          or, with double quotes around cell values:
        </p>
        <pre class="example">
"cell in column 1 and row 1","cell in column 2 and row 1","cell in column 3 and row 1"
"cell in column 1 and row 2","cell in column 2 and row 2","cell in column 3 and row 2"
"cell in column 1 and row 3","cell in column 2 and row 3","cell in column 3 and row 3"
</pre>
        <p>
          CSV files usually have an additional row at the top called a header row, which gives human-readable names or titles for each of the columns. Here is a sample CSV file that contains a header row:
        </p>
        <pre class="example">
<strong>"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"</strong>
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          Column titles are a type of annotation on a column, not part of the data itself. For example, they aren't included when you're counting the rows in a table:
        </p>
        <table class="overlarge">
          <tr><th></th><th>column 1</th><th>column 2</th><th>column 3</th><th>column 4</th><th>column 5</th><th>column 6</th><th>column 7</th></tr>
          <tr><th>titles</th><th>country</th><th>country group</th><th>name (en)</th><th>name (fr)</th><th>name (de)</th><th>latitude</th><th>longitude</th></tr>
          <tr><th>row 1</th><td>AT</td><td>eu</td><td>Austria</td><td>Autriche</td><td>Österreich</td><td>47.6965545</td><td>13.34598005</td>
          <tr><th>row 2</th><td>BE</td><td>eu</td><td>Belgium</td><td>Belgique</td><td>Belgien</td><td>50.501045</td><td>4.47667405</td>
          <tr><th>row 3</th><td>BG</td><td>eu</td><td>Bulgaria</td><td>Bulgarie</td><td>Bulgarien</td><td>42.72567375</td><td>25.4823218</td>
        </table>
      </section>
      <section>
        <h2>How can you provide extra information about CSV data?</h2>
        <p>
          You can provide extra information, known as metadata, about CSV files using a JSON metadata file. If you're just providing metadata about one file, the easiest thing to do is to name the CSV file by adding <code>-metadata.json</code> to the end of the name of the CSV file. For example, if your CSV file is called <code>countries.csv</code> then call the metadata file <code>countries.csv-metadata.json</code>.
        </p>
        <p>
          The simplest metadata file you can create contains a single table description and looks like:
        </p>
        <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  "url": "countries.csv"
}
        </pre>
        <p>
          Metadata files must always include the <code>@context</code> property with a value <code>"http://www.w3.org/ns/csvw"</code>: this enables implementations to tell that these are CSV metadata files. The <code>url</code> property points to the CSV file that the metadata file describes.
        </p>
        <p>
          The description of a table within a metadata file can include:
        </p>
        <ul>
          <li>documentation about the CSV file, such as a description, authorship or licensing information, which can provide context for people using the CSV file</li>
          <li>a definition of the structure of the CSV file, which can be used to validate the data that it holds</li>
          <li>instructions that enable processors to transform the CSV file into other formats, such as JSON or RDF</li>
        </ul>
        <p>
          By default, if implementations can't find a metadata file by appending <code>-metadata.json</code> to the filename of the CSV file, they'll just look for a file called <code>csv-metadata.json</code> in the same directory as the CSV file.
        </p>
        <p>
          Metadata files can also describe several CSV files at once, using a slightly different syntax:
        </p>
        <pre class="example">
  {
    "@context": "http://www.w3.org/ns/csvw",
    <strong>"tables": [{
      "url": "countries.csv"
    }, {
      "url": "country-groups.csv"
    }, {
      "url": "unemployment.csv"
    }]</strong>
  }
        </pre>
        <p>
          Here, the <code>tables</code> property holds an array of table descriptions, each with the URL of the CSV file that it's describing. The metadata file as a whole describes a group of tables.
        </p>
      </section>
      <section id="column-info">
        <h2>How can you provide extra information about the columns in a CSV file?</h2>
        <p>
          You can give information about the columns in a CSV file through a table schema. The simplest thing you can do is say what those columns are called. For example, if you have some CSV like this:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          You can say that the table contains seven columns named as they are in this CSV file like so:
        </p>
        <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  "url": "countries.csv"
  <strong>"tableSchema": {
    "columns": [{
      "titles": "country"
    },{
      "titles": "country group"
    },{
      "titles": "name (en)"
    },{
      "titles": "name (fr)"
    },{
      "titles": "name (de)"
    },{
      "titles": "latitude"
    },{
      "titles": "longitude"
    }]
  }</strong>
}
</pre>
        <p class="note">
          See <a href="#shared-schemas" class="sectionRef"></a> to understand why the property <code>titles</code> is plural.
        </p>
        <p>
          A validator can check that the CSV file holds the expected columns (both the right number of columns and columns with the expected titles).
        </p>
      </section>
    </section>
    <section>
      <h1>Documenting CSVs</h1>
      <p>
        Providing metadata about CSVs can be useful simply in providing extra information to anyone who wants to work with them.
      </p>
      <section>
        <h2>How can you provide documentation about a CSV file?</h2>
        <p>
          Here's an example that includes some extra descriptive documentation about a number of CSV files:
        </p>
        <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  <strong>"dc:title": "Unemployment in Europe (monthly)"
  "dc:description": "Harmonized unemployment data for European countries."
  "dc:creator": "Eurostat",</strong>
  "tables": [{
    "url": "countries.csv",
    <strong>"dc:title": "Countries"</strong>
  }, {
    "url": "country-groups.csv",
    <strong>"dc:title": "Country groups"</strong>
  }, {
    "url": "unemployment.csv",
    <strong>"dc:title": "Unemployment (monthly)",
    "dc:description": "The total number of people unemployed"</strong>
  }]
}
</pre>
        <p>
          This example uses <a href="http://dublincore.org/documents/dcmi-terms/">Dublin Core</a> as a vocabulary for providing metadata. You can tell that's the vocabulary that's being used because the terms like <code>dc:title</code> and <code>dc:description</code> begin with the prefix <code>dc</code>, which stands for Dublin Core.
        </p>
        <p>
          There are several different metadata vocabularies in common use around the web. Some people use <a href="http://dublincore.org/documents/dcmi-terms/">Dublin Core</a>. Some people use <a href="http://schema.org">schema.org</a>. Some people use <a href="http://www.w3.org/TR/vocab-dcat/">DCAT</a>. All of these vocabularies can be used independently or together. A publisher could alternatively use:
        </p>
        <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  <strong>"schema:name": "Unemployment in Europe (monthly)",
  "schema:description": "Harmonized unemployment data for European countries."
  "schema:creator": { "schema:name": "Eurostat" },</strong>
  "tables": [{
    "url": "countries.csv",
    <strong>"schema:name": "Countries"</strong>
  }, {
    "url": "country-groups.csv",
    <strong>"schema:name": "Country groups"</strong>
  }, {
    "url": "unemployment.csv",
    <strong>"schema:name": "Unemployment (monthly)",
    "schema:description": "The total number of people unemployed"</strong>
  }]
}
</pre>
        <p class="note">
          It's not clear at the moment which metadata vocabulary will give publishers the most benefits. Search engines are likely to recognise <a href="http://schema.org">schema.org</a>. RDF-based systems are more likely to recognise Dublin Core.
        </p>
        <p>
          More generally, you can use prefixed properties like these on any of the objects in a metadata document. The prefixes that are recognised are those used in the <a href="http://www.w3.org/2011/rdfa-context/rdfa-1.1">RDFa 1.1 Initial Context</a>. Other properties must be named with full URLs.
        </p>
      </section>
      <section>
        <h2>How can you provide documentation about the columns in a CSV file?</h2>
        <p>
          You can use metadata properties like the ones used for tables for individual columns as well. For example:
        </p>
        <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      <strong>"dc:description": "The ISO two-letter code for a country, in lowercase."</strong>
    },{
      "titles": "country group",
      <strong>"dc:description": "A lowercase two-letter code for a group of countries."</strong>
    },{
      "titles": "name (en)",
      <strong>"dc:description": "The official name of the country in English."</strong>
    },{
      "titles": "name (fr)",
      <strong>"dc:description": "The official name of the country in French."</strong>
    },{
      "titles": "name (de)",
      <strong>"dc:description": "The official name of the country in German."</strong>
    },{
      "titles": "latitude",
      <strong>"dc:description": "The latitude of an indicative point in the country."</strong>
    },{
      "titles": "longitude",
      <strong>"dc:description": "The longitude of an indicative point in the country."</strong>
    }]
  }
}
</pre>
      </section>
      <section>
        <h2>What about when metadata like this is structured?</h2>
        <!-- eg creator with a schema:name, schema:url -->
      </section>
      <section>
        <h2>How should you annotate individual cells?</h2>
      </section>
    </section>
    <section>
      <h1>Validating CSVs</h1>
      <p>
        Validation is all about checking whether a file contains what you expect it to contain. For CSV files, this can be about:
      </p>
      <ul>
        <li>the number of columns there are and what they're called (see <a href="#column-info" class="sectionRef"></a>)</li>
        <li>what kind of values columns contain</li>
        <li>whether any of those values are unique</li>
        <li>whether they match values in other CSV files</li>
      </ul>
      <section>
        <h2>How can you say what kinds of values are expected in a column?</h2>
        <p>
          There's lots more that you can say about the expected content of columns in a CSV file. The most obvious thing is to indicate the data type. For example, with the CSV file:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          The first five columns are strings and the last two are numbers. You can indicate this with the <code>datatype</code> property for each column:
        </p>
        <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      "datatype": "string"
    },{
      "titles": "country group",
      "datatype": "string"
    },{
      "titles": "name (en)",
      "datatype": "string"
    },{
      "titles": "name (fr)",
      "datatype": "string"
    },{
      "titles": "name (de)",
      "datatype": "string"
    },{
      "titles": "latitude",
      "datatype": "number"
    },{
      "titles": "longitude",
      "datatype": "number"
    }]
  }
}
</pre>
        <p class="note">
          You don't have to include <code>"datatype": "string"</code> for columns that are strings &mdash; columns are assumed to hold strings if no datatype is explicitly specified.
        </p>
        <p>
          There are a number of different datatypes supported by CSV on the Web implementations, based on the set defined in [[xmlschema11-2]]. The complete set is shown in the following diagram:
        </p>
        <figure id="fig-datatypes" style="text-align:center">
          <img src="http://www.w3.org/TR/tabular-metadata/datatypes.svg" style="max-width: 600px" alt="Built-in Datatype Hierarchy diagram" longdesc="http://www.w3.org/TR/tabular-metadata/datatypes.html#imageDescription" />
          <figcaption>Diagram showing the built-in datatypes, based on [[xmlschema11-2]]; names in parentheses denote aliases to the [[xmlschema11-2]] terms (see the diagram in <a href="http://www.w3.org/TR/tabular-metadata/datatypes.svg">SVG</a> or <a href="http://www.w3.org/TR/tabular-metadata/datatypes.png">PNG</a> formats)</figcaption>
        </figure>
      </section>
      <section>
        <h2>How do you define new datatypes?</h2>
        <p>
          You can define new datatypes based on the built-in datatypes using an object as the value of the <code>datatype</code> property rather than a string. For example:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  "minimum": "1",
  "maximum": "5"
}</pre>
        <p>
          The <code>base</code> property must be an existing datatype. The other properties on the new datatype define extra restrictions on values of the new datatype. You can give the new datatype a name and description to provide extra documentation for people using the data:
        </p>
        <pre class="example">
"datatype": {
  "dc:title": "Star Rating",
  "dc:description": "A star rating between 1 and 5."
  "base": "integer",
  "minimum": "1",
  "maximum": "5"
}</pre>
      </section>
      <section id="string-restriction">
        <h2>How do you restrict what kind of strings a column contains?</h2>
        <p>
          In the example we've been using, the first column always contains a country code consisting of two lowercase letters. This is a new datatype based on <code>string</code>. You can specify the format for string values in a column using a regular expression, like this:
        </p>
        <pre class="example">{
  "titles": "country",
  "datatype": {
    "dc:title": "Country Code",
    "dc:description": "Country codes as specified in ISO 3166.",
    "base": "string",
    <strong>"format": "[a-z]{2}"</strong>
  }
}
  </pre>
        <p>
          It's also possible to restrict the length of a string-based datatype using the <code>length</code> or <code>minLength</code> and/or <code>maxLength</code> properties. For example the following says that the column holding the English names of countries must have values between 3 and 128 characters long:
        </p>
        <pre class="example">{
  "titles": "name (en)",
  "datatype": {
    "base": "string",
    <strong>"minLength": "3",
    "maxLength": "128"</strong>
  }
}</pre>
      </section>
      <section>
        <h2>How do you restrict the size of numbers a column contains?</h2>
        <p>
          The size of numbers in a column can be restricted using the <code>minimum</code> and <code>maximum</code> properties and/or the <code>minExclusive</code> and <code>maxExclusive</code> properties. In our example, one column contains latitudes, which can range between -90 and +90:
        </p>
        <pre class="example">{
  "titles": "latitude",
  "datatype": {
    "base": "number",
    <strong>"minimum": "-90",
    "maximum": "90"</strong>
  }
}</pre>
      </section>
      <section>
        <h2>How do you ensure that decimal numbers have a particular precision or leading zeros?</h2>
        <p>
          In the example we're using, the latitudes are provided to between six and eight decimal places and there are no leading or trailing zeros. You can use the <code>format</code> property to provide a pattern that matches these numbers. In the pattern, <code>0</code> represents a required digit and <code>#</code> represents an optional digit. For the <code>latitude</code>, the definition looks like:
        </p>
        <pre class="example">{
  "titles": "latitude",
  "datatype": {
    "base": "number",
    "minimum": "-90",
    "maximum": "90",
    <strong>"format": "#0.000000##"</strong>
  }
}</pre>
        <p>
          The <code>format</code> property can also be used to indicate that values in a column should have leading zeros. For example, if a column were supposed to hold a three digit number you could use the pattern <code>000</code>.
        </p>
      </section>
      <section id="number-format">
        <h2>How do you validate numbers that aren't in standard numeric formats?</h2>
        <p>
          Sometimes numbers within a CSV file won't be in a standard numeric format. For example, they might include commas as grouping characters (eg <code>12,345,678</code>) or as decimal points (eg <code>12,3</code>). In these cases, you can use the <code>format</code> property with an object value.
        </p>
        <p>
          To match numbers with grouping separators as in <code>12,345,678</code> you should specify <code>","</code> as the <code>groupChar</code> for the format. The <code>pattern</code> property then holds the pattern that indicates how many digits should be in each group. This example validates numbers with groups of three digits separated by commas:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  <strong>"format": {
    "groupChar": ",",
    "pattern": "#,##0"
  }</strong>
}</pre>
        <p>
          To match numbers with decimal separators other than <code>.</code>, as in <code>12,3</code>, you should specify <code>","</code> as the <code>decimalChar</code> for the format. This example validates numbers with commas as decimal points:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  <strong>"format": {
    "decimalChar": ","
  }</strong>
}</pre>
        <p>
          You can mix and match decimal and grouping characters and patterns. For example, in France it's standard to use commas for decimal points and spaces for grouping characters, so CSV files produced in France might contain numbers like <code>1 234 567,89</code>. These could be validated with a datatype like:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  <strong>"format": {
    "decimalChar": ",",
    "groupChar": " ",
    "pattern": "# ##0,0#"
  }</strong>
}</pre>
      </section>
      <section>
        <h2>How do you restrict what kind of dates and times a column contains?</h2>
        <p>
          Dates and times are treated similarly to numbers. You can use the <code>minimum</code>, <code>maximum</code>, <code>minExclusive</code> and/or <code>maxExclusive</code> properties to restrict their values.
        </p>
        <p>
          For example, to indicate that the column should contain dates later than 1st January 2000, you can use the datatype:
        </p>
        <pre class="example">
"datatype": {
  "base": "date",
  <strong>"minimum": "2000-01-01"</strong>
}</pre>
        <p>
          To indicate that the column should contain times before midday (exclusive), you can use the datatype:
        </p>
        <pre class="example">
"datatype": {
  "base": "time",
  <strong>"minExclusive": "12:00:00"</strong>
}</pre>
        <p class="note">
          The format of dates or times used for minimum or maximum values is always the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format: <code>yyyy-MM-dd</code> for dates, <code>HH:mm:ss.S</code> for times and <code>yyyy-MM-ddTHH:mm:ss.S</code> for date/times.
        </p>
      </section>
      <section id="date-format">
        <h2>How do you validate dates that aren't in standard date or time formats?</h2>
        <p>
          Dates and times in CSV files often come in formats other than the standard <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format. You can use the <code>format</code> property to indicate the expected format of the date or time.
        </p>
        <p>
          For example, to recognise dates in the usual UK format such as 31/10/2015 for 31st October 2015, you could use:
        </p>
        <pre class="example">
"datatype": {
  "base": "date",
  <strong>"format": "dd/MM/yyyy"</strong>
}</pre>
        <p>
          Implementations are only required to understand a particular set of common formats for dates and times. These formats are, for dates:
        </p>
        <ul>
          <li><code>yyyy-MM-dd</code> e.g., <code>2015-03-22</code></li>
          <li><code>yyyyMMdd</code> e.g., <code>20150322</code></li>
          <li><code>dd-MM-yyyy</code> e.g., <code>22-03-2015</code></li>
          <li><code>d-M-yyyy</code> e.g., <code>22-3-2015</code></li>
          <li><code>MM-dd-yyyy</code> e.g., <code>03-22-2015</code></li>
          <li><code>M-d-yyyy</code> e.g., <code>3-22-2015</code></li>
          <li><code>dd/MM/yyyy</code> e.g., <code>22/03/2015</code></li>
          <li><code>d/M/yyyy</code> e.g., <code>22/3/2015</code></li>
          <li><code>MM/dd/yyyy</code> e.g., <code>03/22/2015</code></li>
          <li><code>M/d/yyyy</code> e.g., <code>3/22/2015</code></li>
          <li><code>dd.MM.yyyy</code> e.g., <code>22.03.2015</code></li>
          <li><code>d.M.yyyy</code> e.g., <code>22.3.2015</code></li>
          <li><code>MM.dd.yyyy</code> e.g., <code>03.22.2015</code></li>
          <li><code>M.d.yyyy</code> e.g., <code>3.22.2015</code></li>
        </ul>
        <p>
          For times:
        </p>
        <ul>
          <li><code>HH:mm:ss.S</code> with one or more trailing <code>S</code> characters indicating the maximum number of fractional seconds e.g., <code>HH:mm:ss.SSS</code> for <code>15:02:37.143</code></li>
          <li><code>HH:mm:ss</code> e.g., <code>15:02:37</code></li>
          <li><code>HHmmss</code> e.g., <code>150237</code></li>
          <li><code>HH:mm</code> e.g., <code>15:02</code></li>
          <li><code>HHmm</code> e.g., <code>1502</code></li>
        </ul>
        <p>
          And for date/times:
        </p>
        <ul>
          <li><code>yyyy-MM-ddTHH:mm:ss.S</code> with one or more trailing <code>S</code> characters indicating the maximum number of fractional seconds e.g., <code>yyyy-MM-ddTHH:mm:ss.SSS</code> for <code>2015-03-15T15:02:37.143</code></li>
          <li><code>yyyy-MM-ddTHH:mm:ss</code> e.g., <code>2015-03-15T15:02:37</code></li>
          <li><code>yyyy-MM-ddTHH:mm</code> e.g., <code>2015-03-15T15:02</code></li>
          <li>any of the date formats above, followed by a single space, followed by any of the time formats above, e.g., <code>M/d/yyyy HH:mm</code> for <code>3/22/2015 15:02</code> or <code>dd.MM.yyyy HH:mm:ss</code> for <code>22.03.2015 15:02:37</code></li>
        </ul>
        <p class="note">
          None of these formats include names or abbreviations for months or days. The implementation you use might support other date and time formats as well, including specialised formats for the other date and time datatypes such as <code>gMonthYear</code>. Check your implementation's documentation to see what it supports.
        </p>
      </section>
      <section>
        <h2>How do you validate boolean values that aren't <code>true</code> or <code>false</code>?</h2>
        <p>
          By default, validators will recognise boolean values that are <code>1</code> or <code>0</code> or <code>true</code> or <code>false</code>. If a CSV file contains boolean values like <code>T</code> and <code>F</code> or <code>Yes</code> and <code>No</code> then you can create a derived boolean datatype that uses that syntax using the <code>format</code> property, with the two possible values separated by a <code>|</code>, for example:
        </p>
        <pre class="example">
"datatype": {
  "base": "boolean",
  <strong>"format": "Yes|No"</strong>
}</pre>
      </section>
      <section>
        <h2>How do you specify a list of valid values for a column?</h2>
        <p>
          The example CSV file we're using is this:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          In it, the second column, <code>country group</code>, contains either the value <code>eu</code> or the value <code>non-eu</code>. Despite there being two values, this isn't a boolean column. Instead, it's a column that has only two valid values.
        </p>
        <p>
          There are two ways to specify that a column contains one of a list of values: using a regular expression to list the values and using a reference to a separate CSV file that contains the values.
        </p>
        <section>
          <h3>Using a regular expression</h3>
          <p>
            Using a regular expression to list values works best if those values are strings, if there are only a few of them, and if they are self-explanatory such that you don't want to provide any additional information about them.
          </p>
          <p>
            In this example, the <code>country group</code> column could be specified as:
          </p>
          <pre class="example">{
  "titles": "country group",
  "datatype": {
    "base": "string",
    <strong>"format": "eu|non-eu"</strong>
  }
}</pre>
          <p>
            As described in <a href="#string-restriction" class="sectionRef"></a>, the <code>format</code> property contains a regular expression. List the options separated by <code>|</code> and ensure that you escape any of the characters in the options that have special meaning in regular expressions.
          </p>
        </section>
        <section>
          <h3>Using a separate CSV file</h3>
          <p>
            A more powerful method of listing the valid values in a particular column is to list those values in a separate CSV file. The CSV file can be very simple, containing just a single column that lists the valid values. In this example, we can create <code>country-groups.csv</code> containing:
          </p>
          <pre class="example">
group
eu
non-eu
</pre>
          <p>
            We can then provide definitions for both the <code>countries.csv</code> and <code>country-groups.csv</code> files, and state that the <code>country group</code> column in <code>countries.csv</code> references the <code>group</code> column in <code>country_groups.csv</code>. This reference from one file to another is called a <dfn>foreign key</dfn>.
          </p>
          <p>
            To use a foreign key, both files must be referenced in the same metadata document, and both columns must be given names. Column names are only used inside the metadata document and you can only use (ASCII) letters, numbers, <code>.</code> and <code>_</code> within them. So the basic metadata document, before adding the foreign key, should look like:
          </p>
          <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  "tables": [{
    "url": "countries.csv",
    "tableSchema": {
      "columns": [{
        "titles": "country"
      },{
        <strong>"name": "country_group",</strong>
        "titles": "country group"
      },{
        "titles": "name (en)"
      },{
        "titles": "name (fr)"
      },{
        "titles": "name (de)"
      },{
        "titles": "latitude"
      },{
        "titles": "longitude"
      }]
    }
  }, {
    "url": "country-groups.csv",
    "tableSchema": {
      "columns": [{
        <strong>"name": "group",</strong>
        "titles": "group"
      }]
    }
  }]
}
</pre>
          <p>
            The foreign key is defined in the schema for the <code>countries.csv</code> table, as follows:
          </p>
          <pre class="example">
{
  "@context": "http://www.w3.org/ns/csvw",
  "tables": [{
    "url": "countries.csv",
    "tableSchema": {
      "columns": [{
        "titles": "country"
      },{
        "name": "country_group",
        "titles": "country group"
      },{
        "titles": "name (en)"
      },{
        "titles": "name (fr)"
      },{
        "titles": "name (de)"
      },{
        "titles": "latitude"
      },{
        "titles": "longitude"
      }],
      <strong>"foreignKeys": [{
        "columnReference": "country_group",
        "reference": {
          "resource": "country-groups.csv",
          "columnReference": "group"
        }
      }]</strong>
    }
  }, {
    "url": "country-groups.csv",
    "tableSchema": {
      "columns": [{
        "name": "group",
        "titles": "group"
      }]
    }
  }]
}
</pre>
          <p>
            The <code>foreignKeys</code> property can hold several foreign keys. Each contains a <code>columnReference</code> to a column or list of columns in one CSV file, and a <code>reference</code> which defines a column or list of columns in another CSV file.
          </p>
          <p>
            The advantage of this method of listing the values allowed in a column is that the CSV file that contains the list of possible values can also provide additional information about those values. For example, we can provide expansions of what <code>eu</code> and <code>non-eu</code> mean in different languages:
          </p>
          <pre class="example">
group,name (en),name (fr),name (de)
eu,"European Union","Union européenne","Europäische Union"
non-eu,"Non EU countries","Pays hors Union européenne",Nicht-EU-Länder
</pre>
        </section>
      </section>
      <section>
        <h2>How do you enable a column to have a mix of value types?</h2>
        <p>
          Sometimes a column that contains numbers will contain special values, such as <code>X</code> or <code>NK</code>, when a value is unknown or redacted. If these columns are simply classified as numeric then the non-numeric values will be classed as errors.
        </p>
        <p>
          To avoid values being classified as errors when they are being used to indicate missing values, list those values as null values using the <code>null</code> property. This can take either a single string or an array of strings. For example, the <code>latitude</code> column might usually be numeric but hold an <code>X</code> if there is no indicative point for the country:
        </p>
        <pre class="example">{
  "titles": "latitude",
  <strong>"null": "X",</strong>
  "datatype": {
    "base": "number",
    "minimum": "-90",
    "maximum": "90"
  }
}</pre>
        <p class="note">
          The <code>null</code> property can also be useful when a column contains values that are of the right type but used to indicate a missing value. It's not uncommon, for example, for publishers to use the value <code>99</code> in a column that contains integers to indicate that a value is missing.
        </p>
      </section>
      <section>
        <h2>What if the cells in a column contain lists of values?</h2>
        <p>
          Cells may contain lists of values with spaces, semi-colons or other characters acting as separators. For example, instead of using separate <code>latitude</code> and <code>longitude</code> columns, the CSV that we're looking at could contain a single <code>latlong</code> column consisting of the latitude and longitude separated by a space:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latlong"
"at","eu","Austria","Autriche","Österreich","47.6965545 13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045 4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375 25.4823218"
</pre>
        <p>
          In this scenario, the <code>separator</code> property can be used to indicate that the values in a column are lists themselves, and what separator is used between the items in the list. For example:
        </p>
        <pre class="example">{
  "titles": "latlong",
  <strong>"separator": " ",</strong>
  "datatype": {
    "base": "number",
    "minimum": "-180",
    "maximum": "180"
  }
}</pre>
        <p>
          When <code>separator</code> is specified, the <code>datatype</code> property applies to each of the values in the list. There's no way to indicate that the values in the list have different datatypes, or set limits on the length of the list.
        </p>
      </section>
      <section>
        <h2>How do you ensure every row has a value for a column?</h2>
        <p>
          By default, a validator won't give any errors if a value is missing in a column. If you want to ensure that a value is provided for every row in the column, use the <code>required</code> property for that column, with the value <code>true</code>.
        </p>
        <p>
          In our example, we might say that all the columns are required except the French and German names (applications being expected to default to the English name if the translation is missing):
        </p>
        <pre class="example">
"tableSchema": {
  "columns": [{
    "titles": "country",
    <strong>"required": true</strong>
  },{
    "titles": "country group",
    <strong>"required": true</strong>
  },{
    "titles": "name (en)",
    <strong>"required": true</strong>
  },{
    "titles": "name (fr)"    
  },{
    "titles": "name (de)"
  },{
    "titles": "latitude",
    <strong>"required": true</strong>
  },{
    "titles": "longitude",
    <strong>"required": true</strong>
  }]
}
</pre>
        <p class="note">
          Setting <code>required</code> to <code>true</code> means that you can't have any null values in a column. If, in this example, <code>latitude</code> and <code>longitude</code> had <code>null</code> set to <code>X</code> then those columns couldn't contain an <code>X</code>. It doesn't usually make sense to specify both <code>null</code> and <code>required</code>.
        </p>
      </section>
      <section>
        <h2>How do you indicate all the values in a column are unique?</h2>
        <p>
          In our example, the <code>country</code> column must contain unique values: each row should define a different country. To specify this, you can use a primary key to refer to the name of the column:
        </p>
        <pre class="example">
"tableSchema": {
  "columns": [{
    <strong>"name": "country",</strong>
    "titles": "country"
  },{
    "titles": "country group"
  },{
    "titles": "name (en)"
  },{
    "titles": "name (fr)"
  },{
    "titles": "name (de)"
  },{
    "titles": "latitude"
  },{
    "titles": "longitude"
  }],
  <strong>"primaryKey": "country"</strong>
}
</pre>
        <p>
          Each CSV file can only have one primary key. A primary key can be made up of a number of columns that have to be unique in combination: the classic example would be <code>["firstName", "lastName"]</code>.
        </p>
      </section>
    </section>
    <section>
      <h1>Transforming CSVs</h1>
      <section>
        <h2>What can you transform CSV into?</h2>
      </section>
      <section>
        <h2>What values get used in the output of a transformation?</h2>
      </section>
      <section>
        <h2>What value gets used in the output if it's missing in the CSV?</h2>
      </section>
      <section>
        <h2>What properties get used in the output of a transformation?</h2>
      </section>
      <section>
        <h2>How do you map values into URLs?</h2>
      </section>
      <section>
        <h2>How do you indicate the type of the thing described by each row?</h2>
      </section>
      <section>
        <h2>How can you add extra output into the result?</h2>
      </section>
      <section>
        <h2>How can you remove output from the result?</h2>
      </section>
      <section>
        <h2>How do you transform into nested structures in JSON?</h2>
      </section>
      <section>
        <h2>How do you indicate that values should be mapped to a list rather than repeating properties in RDF?</h2>
      </section>
      <section>
        <h2>How should you transform CSV into JSON-LD?</h2>
      </section>
      <section>
        <h2>How should you display CSV tables in HTML?</h2>
      </section>
      <section>
        <h2>How can you transform CSV into the DataCube vocabulary?</h2>
        <!-- see https://github.com/w3c/csvw/blob/gh-pages/examples/rdf-data-cube-example.md -->
      </section>
      <section>
        <h2>How can you transform CSV into other formats?</h2>
      </section>
    </section>
    <section>
      <h1>Multi-lingual CSVs</h1>
      <p>
        There are a number of features in the CSV on the Web metadata documents that support scenarios encountered in CSV files that use different languages. We already discussed using varying number formats in <a href="#number-format" class="sectionRef"></a> and date formats in <a href="#date-format" class="sectionRef"></a>. Here we'll look at how to create metadata files, schemas and CSV files that work across multiple languages.
      </p>
      <section>
        <h2>How do you indicate the language used by the metadata file?</h2>
        <p>
          The metadata file will often contain natural language text, such as titles and descriptions of columns and tables. Unless you specify otherwise, implementations will assume all this text is in an undefined language (<code>und</code>). If you want to specify what natural language is in use within the metadata file, you have to change the way the <code>@context</code> is specified. Instead of the normal value:
        </p>
        <pre class="example">
"@context": "http://www.w3.org/ns/csvw"
</pre>
        <p>
          The <code>@context</code> should take an array, where the first value is the usual URL as a string and the second is an object with a <code>@language</code> property set to the language being used within the metadata file. This example, which has English-language titles and descriptions, illustrates:
        </p>
        <pre class="example">
{
  <strong>"@context": [ "http://www.w3.org/ns/csvw", { "@language": "en "} ],</strong>
  "dc:title": "Countries"
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      "dc:description": "The ISO two-letter code for a country, in lowercase."
    },{
      "titles": "country group",
      "dc:description": "A lowercase two-letter code for a group of countries."
    },{
      "titles": "name (en)",
      "dc:description": "The official name of the country in English."
    },{
      "titles": "name (fr)",
      "dc:description": "The official name of the country in French."
    },{
      "titles": "name (de)",
      "dc:description": "The official name of the country in German."
    },{
      "titles": "latitude",
      "dc:description": "The latitude of an indicative point in the country."
    },{
      "titles": "longitude",
      "dc:description": "The longitude of an indicative point in the country."
    }]
  }
}
</pre>
      </section>
      <section>
        <h2>How do you provide metadata such as descriptions in different languages?</h2>
        <p>
          Metadata such as descriptions can be objects rather than strings. Using objects is useful when you want to provide the language for a value. In this case, the object should have two properties: a <code>@value</code> property holding the natural-language string and a <code>@lang</code> value indicating what language that string is in. For example:
        </p>
        <pre class="example">
{
  "titles": "name (en)",
  "dc:description": <strong>{ 
    "@value": "The official name of the country in English.",
    "@lang": "en"
  }</strong>
}</pre>
        <p>
          You can use an array to provide the same metadata in many different languages, for example:
        </p>
        <pre class="example">
"dc:title": [{
  "@lang": "en",
  "@value": "Unemployment in Europe (monthly)"
},{
  "@lang": "de",
  "@value": "Arbeitslosigkeit in Europa (monatlich)"
},{
  "@lang": "fr",
  "@value": "Le Chômage en Europe (mensuel)"
}]
        </pre>
        <p class="note">
          If you don't indicate the language used for metadata, processors will assume it's the default language used in the metadata as a whole.
        </p>
      </section>
      <section>
        <h2>How do you provide titles for columns in different languages?</h2>
        <p>
          You can use an object as the value for the <code>titles</code> property for a column to provide titles in different languages. Within the object, each property is a language and the value is the title in that language:
        </p>
        <pre class="example">
"titles": {
  "en": "Country",
  "de": "Land",
  "fr": "Pays"
}</pre>
        <p class="note">
          If you don't indicate the language used for the title of a column, processors will assume it's the default language used in the metadata as a whole.
        </p>
      </section>
      <section>
        <h2>How do you specify the language of the values in a column?</h2>
        <p>
          Within an individual CSV file, it may be that different columns contain values that are in different languages. In the example we're using, there are three columns that each contain the name of a country, in English, French and German:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latlong"
"at","eu","Austria","Autriche","Österreich","47.6965545 13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045 4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375 25.4823218"
</pre>
        <p>
          Use the <code>lang</code> property on the column description to indicate the language of text in that column:
        </p>
        <pre class="example">
{
  <strong>"@context": [ "http://www.w3.org/ns/csvw", { "@language": "en "} ],</strong>
  "dc:title": "Countries"
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      "dc:description": "The ISO two-letter code for a country, in lowercase."
    },{
      "titles": "country group",
      "dc:description": "A lowercase two-letter code for a group of countries."
    },{
      "titles": "name (en)",
      "dc:description": "The official name of the country in English.",
      <strong>"lang": "en"</strong>
    },{
      "titles": "name (fr)",
      "dc:description": "The official name of the country in French.",
      <strong>"lang": "fr"</strong>
    },{
      "titles": "name (de)",
      "dc:description": "The official name of the country in German.",
      <strong>"lang": "de"</strong>
    },{
      "titles": "latitude",
      "dc:description": "The latitude of an indicative point in the country."
    },{
      "titles": "longitude",
      "dc:description": "The longitude of an indicative point in the country."
    }]
  }
}
</pre>
        <p class="note">
          There's no relationship between the language used in a metadata file and that used in the CSV file that it describes.
        </p>
      </section>
      <section>
        <h2>How do you indicate that tables should be displayed right-to-left?</h2>
        <p>
          Implementations that display tables according to the specs should mostly be able to guess whether a table should be displayed left-to-right or right-to-left based on the content of the table. Implementations will look at the content of the cells to work out which way to display their content and will look at the content of the table as a whole to work out whether to display the first column on the right or left of the page.
        </p>
        <p>
          If you want to override the display of a particular column then you can use the <code>textDirection</code> property on a column description to explicitly be <code>rtl</code> or <code>ltr</code>:
        </p>
        <pre class="example">
{
  "titles": "name (ar)",
  "lang": "ar",
  <strong>"textDirection": "rtl"</strong>
}
        </pre>
        <p>
          If you want to override the display of the table overall then you can use the <code>tableDirection</code> property on the description of the table, or for all tables in the group.
        </p>
        <pre class="example">
{
  <strong>"@context": "http://www.w3.org/ns/csvw",</strong>
  "url": "results.csv",
  <strong>"tableDirection": "rtl"</strong>
}
</pre>
        <p>
          The value of the <code>tableDirection</code> property is inherited to all columns in the table, so any text within this table will similarly be displayed right-to-left. This can be overridden by setting <code>textDirection</code> to <code>ltr</code> or <code>auto</code> (in which case the direction of the text within each cell will be determined by its contents).
        </p>
      </section>
    </section>
    <section>
      <h1>Advanced Use</h1>
      <section>
        <h2>How do you support units of measure?</h2>
        <p>
          There is no native support for expressing the units of measure for a particular column. You can, however, use documentation to tell people who are using the data what unit of measure is used for that particular column. This can be informal within the description of the column:
        </p>
        <pre class="example">
{
  "titles": "distance",
  "dc:description": "Distance (kilometres)"
}</pre>
        <p>
          Alternatively, it can be more explicit using an existing units-of-measure property and vocabulary, such as:
        </p>
        <pre class="example">
{
  "titles": "distance",
  "http://purl.org/linked-data/sdmx/2009/attribute#unitMeasure": { "@id": "http://qudt.org/vocab/unit#Kilometre" }
}</pre>
        <section>
          <h3>Transforming to structured values</h3>
          <p>
            If you are generating JSON or RDF from CSV, you may want to generate structured values that include the units of each value from the CSV file. This is a little complicated, but useful if different rows contain values that use different units. In this case, the output that you're aiming for in RDF would look something like:
          </p>
          <pre class="example">
[] :distance &lt;#row-1-distance&gt; .

&lt;#row-1-distance&gt;
  schema:value 3.5 ;
  schema:unitCode &lt;http://qudt.org/vocab/unit#Kilometre&gt; ;
  .
</pre>
          <p>
            and in JSON something like this:
          </p>
          <pre class="example">
  "distance": {
    "@id": "#row-1-distance",
    "schema:value": 3.5
    "schema:unitCode": "http://qudt.org/vocab/unit#Kilometre"
  }
  </pre>
          <p class="note">
            You may want to use different properties than <code>schema:value</code> and <code>schema:unitCode</code>; if so, just use different <code>propertyUrl</code>s.
          </p>
          <p>
            You need to decide on a pattern for the URLs for the values themselves, and set the <code>aboutUrl</code> for the relevant column create that URL. In this example, the URLs that look like <code>#row-1-distance</code> can be generated with the pattern <code>#row-{_row}-distance</code>. The <code>propertyUrl</code> for the column needs to be <code>schema:value</code> as the value in the column provides the value for that property. So the column description looks like:
          </p>
          <pre class="example">
  {
    "name": "distance_value",
    "titles": "distance",
    "datatype": "number",
    "aboutUrl": "#row-{_row}-distance",
    "propertyUrl": "schema:value"
  }</pre>
          <p>
            You then need to use virtual columns (descriptions of additional columns that don't exist in the source CSV) to generate the relationship between the thing whose distance is being measured and the structured value, and the additional property providing the unit for the structured value.
          </p>
          <p>
            To generate the relationship being the thing that has the distance and the structured value, the virtual column's <code>valueUrl</code> needs to hold the same URL template as you used before:
          </p>
          <pre class="example">
  {
    "name": "distance",
    "virtual": true,
    "valueUrl": "#row-{_row}-distance"
  }</pre>
          <p>
            To create the units property, you need another virtual column where the <code>aboutUrl</code> of that virtual column generates the URL for the structured value, the <code>propertyUrl</code> is <code>schema:unitCode</code> and the <code>valueUrl</code> is the URL representing the unit (in this case <code>http://qudt.org/vocab/unit#Kilometre</code>):
          </p>
          <pre class="example">
  {
    "name": "distance_unit",
    "aboutUrl": "#row-{_row}-distance",
    "propertyUrl": "schema:unitCode",
    "valueUrl": "http://qudt.org/vocab/unit#Kilometre"
  }</pre>
        </section>
        <section>
          <h3>Named datatypes in RDF</h3>
          <p>
            If you are generating RDF from CSV, you may want to define a datatype for a column and then provide additional information about that datatype as properties. For example, the column description could look like:
          </p>
          <pre class="example">
{
  "titles": "distance",
  "datatype": {
    "@id": "http://example.org/unit/kilometre",
    "rdfs:label": "Kilometre",
    "base": "number" <!-- TODO here: use standard property IDs if possible -->
  }
}</pre>
          <p>
            When values are generated in RDF for this column, they will be assigned the relevant datatype, for example:
          </p>
          <pre class="example">
[] :distance "3.5"^^&lt;http://example.org/unit/kilometre&gt; .

&lt;http://example.org/unit/kilometre&gt; rdfs:label "Kilometre" .
</pre>
        </section>
      </section>
      <section id="shared-schemas">
        <h2>How can you specify a single schema for multiple CSV files?</h2>
      </section>
      <section>
        <h2>How can you provide a label for a row?</h2>
      </section>
      <section>
        <h2>What about CSV that isn't standard CSV?</h2>
      </section>
      <section>
        <h2>What about tables in HTML?</h2>
      </section>
      <section>
        <h2>What if you want to put metadata files somewhere else?</h2>
      </section>
    </section>
  </body>
</html>

