## CSV+ tests
## Distributed under both the W3C Test Suite License[1] and the W3C 3-
## clause BSD License[2]. To contribute to a W3C Test Suite, see the
## policies and contribution forms [3]
##
## 1. http://www.w3.org/Consortium/Legal/2008/04-testsuite-license
## 2. http://www.w3.org/Consortium/Legal/2008/03-bsd-license
## 3. http://www.w3.org/2004/10/27-testcases
##
## Test types (for now)
## * CsvToJsonTest  - tests CSV evaluation to JSON
## * CsvToRdfTest   - tests CSV evaluation to RDF using graph isomorphism
## * CsvSparqlTest - tests CSV evaulation to RDF using SPARQL ASK query

@prefix : <manifest-rdf#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mf:   <http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#> .
@prefix csvt: <http://www.w3.org/2013/csvw/tests/vocab#> .

<manifest-rdf>  a mf:Manifest ;

  rdfs:label "CSVW RDF Tests";
  rdfs:comment "Tests transformation of CSV to RDF.";
  mf:entries (
    :test001 :test002 :test003 :test005 :test006 :test007 :test008 :test009 :test010 :test011
    :test012 :test013 :test014 :test015 :test016 :test017 :test018 :test019 :test020 :test021
    :test022 :test023 :test024 :test025 :test026 :test027 :test028 :test029 :test030 :test031
    :test032 :test033 :test034 :test035 :test036 :test037 :test038 :test039 :test040 :test041
    :test042 :test043 :test044 :test045 :test046 :test047 :test048 :test049 :test050 :test051
    :test052 :test054 :test055 :test056 :test057 :test058 :test059 :test060 :test061 :test062
    :test063 :test065 :test066 :test067 :test068 :test069 :test070 :test071 :test072 :test073
    :test075 :test076 :test093 :test095 :test097 :test098 :test099 :test101 :test102 :test106
    :test109 :test110 :test111 :test112 :test113 :test114 :test115 :test116 :test117 :test118
    :test119 :test120 :test121 :test122 :test123 :test124 :test125 :test126 :test127 :test129
    :test130 :test131 :test132 :test147 :test148 :test149 :test150 :test151 :test152 :test153
    :test154 :test155 :test156 :test157 :test158 :test159 :test160 :test161 :test162 :test163
    :test164 :test165 :test166 :test167 :test168 :test169 :test170 :test171 :test172 :test173
    :test174 :test175 :test176 :test177 :test178 :test179 :test180 :test181 :test182 :test183
    :test184 :test185 :test186 :test187 :test188 :test189 :test190 :test191 :test192 :test193
    :test194 :test195 :test196 :test197 :test198 :test199 :test200 :test201 :test202 :test203
    :test204 :test205 :test206 :test207 :test208 :test209 :test210 :test211 :test212 :test213
    :test214 :test215 :test216 :test217 :test218 :test219 :test220 :test221 :test222 :test223
    :test224 :test225 :test226 :test227 :test228 :test229 :test230 :test231 :test232 :test233
    :test234 :test235 :test236 :test237 :test238 :test242 :test243 :test244 :test245 :test246
    :test247 :test248
  ) .

:test001 a csvt:ToRdfTest;
  mf:name "Simple table";
  rdfs:comment "The simplest possible table without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test001.csv>;
  mf:result <test001.ttl>;
  .

:test002 a csvt:ToRdfTest;
  mf:name "Quoted field";
  rdfs:comment "Table with one quoted field without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test002.csv>;
  mf:result <test002.ttl>;
  .

:test003 a csvt:ToRdfTest;
  mf:name "Surrounding spaces";
  rdfs:comment "Table with whitespace before and after every field without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test003.csv>;
  mf:result <test003.ttl>;
  .

:test005 a csvt:ToRdfTest;
  mf:name "Identifier references";
  rdfs:comment "A table with entity identifiers and references to other entities without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test005.csv>;
  mf:result <test005.ttl>;
  .

:test006 a csvt:ToRdfTest;
  mf:name "No identifiers";
  rdfs:comment "Records contain two entities with relationships which are duplicated without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test006.csv>;
  mf:result <test006.ttl>;
  .

:test007 a csvt:ToRdfTest;
  mf:name "Joined table with unique identifiers";
  rdfs:comment "Joined data with identified records without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test007.csv>;
  mf:result <test007.ttl>;
  .

:test008 a csvt:ToRdfTest;
  mf:name "Microsyntax - internal field separator";
  rdfs:comment "One field has comma-separated values without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test008.csv>;
  mf:result <test008.ttl>;
  .

:test009 a csvt:ToRdfTest;
  mf:name "Microsyntax - formatted time";
  rdfs:comment "Field with parseable human formatted time without metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test009.csv>;
  mf:result <test009.ttl>;
  .

:test010 a csvt:ToRdfTest;
  mf:name "Country-codes-and-names example";
  rdfs:comment "Country-codes-and-names example";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test010.csv>;
  mf:result <test010.ttl>;
  .

:test011 a csvt:ToRdfTest;
  mf:name "tree-ops example with metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test011/tree-ops.csv>;
  mf:result <test011/result.ttl>;
  csvt:implicit <test011/tree-ops.csv-metadata.json>;
  .

:test012 a csvt:ToRdfTest;
  mf:name "tree-ops example with directory metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test012/tree-ops.csv>;
  mf:result <test012/result.ttl>;
  csvt:implicit <test012/metadata.json>;
  .

:test013 a csvt:ToRdfTest;
  mf:name "tree-ops example from user metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test013-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test013.ttl>;
  csvt:implicit <test013-user-metadata.json>;
  .

:test014 a csvt:ToRdfTest;
  mf:name "tree-ops example with linked metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  mf:action <test014/tree-ops.csv>;
  mf:result <test014/result.ttl>;
  csvt:implicit <test014/linked-metadata.json>;
  .

:test015 a csvt:ToRdfTest;
  mf:name "tree-ops example with user and directory metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test015/user-metadata.json>;
  ];
  mf:action <test015/tree-ops.csv>;
  mf:result <test015/result.ttl>;
  csvt:implicit <test015/metadata.json>,
    <test015/user-metadata.json>;
  .

:test016 a csvt:ToRdfTest;
  mf:name "tree-ops example with linked and directory metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  mf:action <test016/tree-ops.csv>;
  mf:result <test016/result.ttl>;
  csvt:implicit <test016/metadata.json>,
    <test016/linked-metadata.json>;
  .

:test017 a csvt:ToRdfTest;
  mf:name "tree-ops example with file and directory metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test017/tree-ops.csv>;
  mf:result <test017/result.ttl>;
  csvt:implicit <test017/tree-ops.csv-metadata.json>,
    <test017/metadata.json>;
  .

:test018 a csvt:ToRdfTest;
  mf:name "tree-ops example with user, file and directory metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test018/user-metadata.json>;
  ];
  mf:action <test018/tree-ops.csv>;
  mf:result <test018/result.ttl>;
  csvt:implicit <test018/tree-ops.csv-metadata.json>,
    <test018/metadata.json>,
    <test018/user-metadata.json>;
  .

:test019 a csvt:ToRdfTest;
  mf:name "no header";
  rdfs:comment "If a CSV+ file does not include a header line, this MUST be specified using the `header` parameter.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test019.ttl>;
  csvt:contentType "text/csv;header=absent";
  .

:test020 a csvt:ToRdfTest;
  mf:name "dialect: trim=start";
  rdfs:comment "If `trim` is `true` or "start" then whitespace from the start of values that are not enclosed MUST be removed from the value.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test020-metadata.json>;
  mf:result <test020.ttl>;
  csvt:implicit <test020.csv>;
  .

:test021 a csvt:ToRdfTest;
  mf:name "dialect: trim=end";
  rdfs:comment "If `trim` is `true` or "end" then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test021-metadata.json>;
  mf:result <test021.ttl>;
  csvt:implicit <test021.csv>;
  .

:test022 a csvt:ToRdfTest;
  mf:name "dialect: trim=true";
  rdfs:comment "If `trim` is `true` or "start" then whitespace from the start of values that are not enclosed MUST be removed from the value. If `trim` is `true` or "end" then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test022-metadata.json>;
  mf:result <test022.ttl>;
  csvt:implicit <test022.csv>;
  .

:test023 a csvt:ToRdfTest;
  mf:name "dialect: header=false";
  rdfs:comment "If `true`, sets the `header row count` flag to 1, and if `false` to 0, unless `headerRowCount` is provided, in which case the value provided for the `header` property is ignored.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test023-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test023.ttl>;
  csvt:implicit <test023-user-metadata.json>;
  .

:test024 a csvt:ToRdfTest;
  mf:name "dialect: header=false and headerRowCount=1";
  rdfs:comment "If `true`, sets the `header row count` flag to 1, and if `false` to 0, unless `headerRowCount` is provided, in which case the value provided for the `header` property is ignored.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test024-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test024.ttl>;
  csvt:implicit <test024-user-metadata.json>;
  .

:test025 a csvt:ToRdfTest;
  mf:name "dialect: header=false and skipRows=1";
  rdfs:comment "Ignore header uses column definitions from metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test025-user-metadata.json>;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test025.ttl>;
  csvt:implicit <test025-user-metadata.json>;
  .

:test026 a csvt:ToRdfTest;
  mf:name "tree-ops example with directory metadata";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test026/metadata.json>;
  mf:result <test026/result.ttl>;
  csvt:implicit <test026/tree-ops.csv>;
  .

:test027 a csvt:ToRdfTest;
  mf:name "tree-ops minimal output";
  rdfs:comment "Processors MUST use the first metadata found for processing a tabular data file by using overriding metadata, if provided. Otherwise processors MUST attempt to locate the first metadata document from the Link header, the file-specific metadata, or the directory-specific metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test027-user-metadata.json>;
    csvt:minimal true;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test027.ttl>;
  csvt:implicit <test027-user-metadata.json>;
  .

:test028 a csvt:ToRdfTest;
  mf:name "countries.csv example";
  rdfs:comment "If no metadata is supplied or found, processors MUST use embedded metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <countries.csv>;
  mf:result <test028.ttl>;
  .

:test029 a csvt:ToRdfTest;
  mf:name "countries.csv minimal";
  rdfs:comment "If no metadata is supplied or found, processors MUST use embedded metadata.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <countries.csv>;
  mf:result <test029.ttl>;
  .

:test030 a csvt:ToRdfTest;
  mf:name "countries.json example";
  rdfs:comment "countries.json from metadata";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <countries.json>;
  mf:result <test030.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test031 a csvt:ToRdfTest;
  mf:name "countries.json example minimal output";
  rdfs:comment "countries.json from metadata minimal output";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <countries.json>;
  mf:result <test031.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test032 a csvt:ToRdfTest;
  mf:name "events-listing.csv example";
  rdfs:comment "events-listing example from metadata, virtual columns and multiple subjects per row";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test032/metadata.json>;
  mf:result <test032/result.ttl>;
  csvt:implicit <test032/events-listing.csv>;
  .

:test033 a csvt:ToRdfTest;
  mf:name "events-listing.csv minimal output";
  rdfs:comment "events-listing example from metadata, virtual columns and multiple subjects per row; minimal output";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <test033/metadata.json>;
  mf:result <test033/result.ttl>;
  csvt:implicit <test033/events-listing.csv>;
  .

:test034 a csvt:ToRdfTest;
  mf:name "roles example";
  rdfs:comment "Public Sector Roles example with referenced schemas";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test034/metadata.json>;
  mf:result <test034/result.ttl>;
  csvt:implicit <test034/senior-roles.csv>,
    <test034/junior-roles.csv>,
    <test034/gov.uk/data/organizations.csv>,
    <test034/gov.uk/data/professions.csv>,
    <test034/gov.uk/schema/junior-roles.json>,
    <test034/gov.uk/schema/senior-roles.json>,
    <test034/gov.uk/schema/organizations.json>,
    <test034/gov.uk/schema/professions.json>;
  .

:test035 a csvt:ToRdfTest;
  mf:name "roles minimal";
  rdfs:comment "Public Sector Roles example with referenced schemas; minimal output";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <test035/metadata.json>;
  mf:result <test035/result.ttl>;
  csvt:implicit <test035/senior-roles.csv>,
    <test035/junior-roles.csv>,
    <test035/gov.uk/data/organizations.csv>,
    <test035/gov.uk/data/professions.csv>,
    <test035/gov.uk/schema/junior-roles.json>,
    <test035/gov.uk/schema/senior-roles.json>,
    <test035/gov.uk/schema/organizations.json>,
    <test035/gov.uk/schema/professions.json>;
  .

:test036 a csvt:ToRdfTest;
  mf:name "tree-ops-ext example";
  rdfs:comment "tree-ops extended example";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test036/tree-ops-ext.csv>;
  mf:result <test036/result.ttl>;
  csvt:implicit <test036/tree-ops-ext.csv-metadata.json>;
  .

:test037 a csvt:ToRdfTest;
  mf:name "tree-ops-ext minimal";
  rdfs:comment "tree-ops extended example; minimal output";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <test037/tree-ops-ext.csv>;
  mf:result <test037/result.ttl>;
  csvt:implicit <test037/tree-ops-ext.csv-metadata.json>;
  .

:test038 a csvt:ToRdfTest;
  mf:name "inherited properties propagation";
  rdfs:comment "Setting inherited properties at different levels inherit to cell";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test038-metadata.json>;
  mf:result <test038.ttl>;
  csvt:implicit <test038.csv>;
  .

:test039 a csvt:ToRdfTest;
  mf:name "valid inherited properties";
  rdfs:comment "Different combinations of valid inherited properties";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test039-metadata.json>;
  mf:result <test039.ttl>;
  csvt:implicit <test039.csv>;
  .

:test040 a csvt:ToRdfTest;
  mf:name "invalid null";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test040-metadata.json>;
  mf:result <test040.ttl>;
  csvt:implicit <test040.csv>;
  .

:test041 a csvt:ToRdfTest;
  mf:name "invalid lang";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test041-metadata.json>;
  mf:result <test041.ttl>;
  csvt:implicit <test041.csv>;
  .

:test042 a csvt:ToRdfTest;
  mf:name "invalid textDirection";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test042-metadata.json>;
  mf:result <test042.ttl>;
  csvt:implicit <test042.csv>;
  .

:test043 a csvt:ToRdfTest;
  mf:name "invalid separator";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test043-metadata.json>;
  mf:result <test043.ttl>;
  csvt:implicit <test043.csv>;
  .

:test044 a csvt:ToRdfTest;
  mf:name "invalid ordered";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test044-metadata.json>;
  mf:result <test044.ttl>;
  csvt:implicit <test044.csv>;
  .

:test045 a csvt:ToRdfTest;
  mf:name "invalid default";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test045-metadata.json>;
  mf:result <test045.ttl>;
  csvt:implicit <test045.csv>;
  .

:test046 a csvt:ToRdfTest;
  mf:name "invalid dataype";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test046-metadata.json>;
  mf:result <test046.ttl>;
  csvt:implicit <test046.csv>;
  .

:test047 a csvt:ToRdfTest;
  mf:name "invalid aboutUrl";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test047-metadata.json>;
  mf:result <test047.ttl>;
  csvt:implicit <test047.csv>;
  .

:test048 a csvt:ToRdfTest;
  mf:name "invalid propertyUrl";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test048-metadata.json>;
  mf:result <test048.ttl>;
  csvt:implicit <test048.csv>;
  .

:test049 a csvt:ToRdfTest;
  mf:name "invalid valueUrl";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test049-metadata.json>;
  mf:result <test049.ttl>;
  csvt:implicit <test049.csv>;
  .

:test050 a csvt:ToRdfTest;
  mf:name "dialect: delimiter";
  rdfs:comment "Recognizes tab-separated-values with appropriate `delimiter`";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test050-metadata.json>;
  mf:result <test050.ttl>;
  csvt:implicit <tree-ops.tsv>;
  .

:test051 a csvt:ToRdfTest;
  mf:name "dialect: commentPrefix in header";
  rdfs:comment "Adds comments when found in `skipRows`";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test051-metadata.json>;
  mf:result <test051.ttl>;
  csvt:implicit <test051.csv>;
  .

:test052 a csvt:ToRdfTest;
  mf:name "dialect: commentPrefix in rows";
  rdfs:comment "Adds comments when found in `content`";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test052-metadata.json>;
  mf:result <test052.ttl>;
  csvt:implicit <test052.csv>;
  .

:test054 a csvt:ToRdfTest;
  mf:name "dialect: skipColumns";
  rdfs:comment "Ignores skipped columns";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test054-metadata.json>;
  mf:result <test054.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test055 a csvt:ToRdfTest;
  mf:name "dialect: skipBlankRows";
  rdfs:comment "Ignores rows in which all columns are empty";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test055-metadata.json>;
  mf:result <test055.ttl>;
  csvt:implicit <test055.csv>;
  .

:test056 a csvt:ToRdfTest;
  mf:name "dialect: skipInitialSpace";
  rdfs:comment "Equivalent to` trim="start"`";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test056-metadata.json>;
  mf:result <test056.ttl>;
  csvt:implicit <test056.csv>;
  .

:test057 a csvt:ToRdfTest;
  mf:name "dialect as URL reference";
  rdfs:comment "Loads a `dialect description` if referenced using a URL";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test057-metadata.json>;
  mf:result <test057.ttl>;
  csvt:implicit <test057.csv>,
    <test057-dialect.json>;
  .

:test058 a csvt:ToRdfTest;
  mf:name "table dialect vs tablegroup dialect";
  rdfs:comment "A dialect defined in a Table completely overrides that defined in a TableGroup";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test058-metadata.json>;
  mf:result <test058.ttl>;
  csvt:implicit <test058.csv>;
  .

:test059 a csvt:ToRdfTest;
  mf:name "dialect: invalid commentPrefix";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test059-metadata.json>;
  mf:result <test059.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test060 a csvt:ToRdfTest;
  mf:name "dialect: invalid delimiter";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test060-metadata.json>;
  mf:result <test060.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test061 a csvt:ToRdfTest;
  mf:name "dialect: invalid doubleQuote";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test061-metadata.json>;
  mf:result <test061.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test062 a csvt:ToRdfTest;
  mf:name "dialect: invalid encoding";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test062-metadata.json>;
  mf:result <test062.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test063 a csvt:ToRdfTest;
  mf:name "dialect: invalid header";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test063-metadata.json>;
  mf:result <test063.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test065 a csvt:ToRdfTest;
  mf:name "dialect: invalid headerRowCount";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test065-metadata.json>;
  mf:result <test065.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test066 a csvt:ToRdfTest;
  mf:name "dialect: invalid lineTerminators";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test066-metadata.json>;
  mf:result <test066.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test067 a csvt:ToRdfTest;
  mf:name "dialect: invalid quoteChar";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test067-metadata.json>;
  mf:result <test067.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test068 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipBlankRows";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test068-metadata.json>;
  mf:result <test068.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test069 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipColumns";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test069-metadata.json>;
  mf:result <test069.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test070 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipInitialSpace";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test070-metadata.json>;
  mf:result <test070.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test071 a csvt:ToRdfTest;
  mf:name "dialect: invalid skipRows";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test071-metadata.json>;
  mf:result <test071.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test072 a csvt:ToRdfTest;
  mf:name "dialect: invalid trim";
  rdfs:comment "If a property has a value that is not permitted by this specification, then if a default value is provided for that property, compliant applications MUST use that default value and MUST generate a warning. If no default value is provided for that property, compliant applications MUST generate a warning and behave as if the property had not been specified.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test072-metadata.json>;
  mf:result <test072.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test073 a csvt:ToRdfTest;
  mf:name "invalid @language";
  rdfs:comment "The value of `@language` MUST be a valid `BCP47` language code";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test073-metadata.json>;
  mf:result <test073.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test075 a csvt:ToRdfTest;
  mf:name "invalid tableGroup tableDirection";
  rdfs:comment "An atomic property that MUST have a single string value that is one of "rtl", "ltr" or "default".";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test075-metadata.json>;
  mf:result <test075.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test076 a csvt:ToRdfTest;
  mf:name "invalid table tableDirection";
  rdfs:comment "An atomic property that MUST have a single string value that is one of "rtl", "ltr" or "default".";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test076-metadata.json>;
  mf:result <test076.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test093 a csvt:ToRdfTest;
  mf:name "undefined properties";
  rdfs:comment "Compliant applications MUST ignore properties (aside from _common properties_) which are not defined in this specification and MUST generate a warning when they are encoutered";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test093-metadata.json>;
  mf:result <test093.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test095 a csvt:ToRdfTest;
  mf:name "inconsistent array values: transformations";
  rdfs:comment "Any items within an array that are not valid objects of the type expected are ignored";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test095-metadata.json>;
  mf:result <test095.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test097 a csvt:ToRdfTest;
  mf:name "inconsistent array values: foreignKeys";
  rdfs:comment "Any items within an array that are not valid objects of the type expected are ignored";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test097-metadata.json>;
  mf:result <test097.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test098 a csvt:ToRdfTest;
  mf:name "inconsistent array values: tables";
  rdfs:comment "If the supplied value of an array property is not an array (eg if it is an integer), compliant applications MUST issue a warning and proceed as if the property had been supplied with an empty array";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test098-metadata.json>;
  mf:result <test098.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test099 a csvt:ToRdfTest;
  mf:name "inconsistent array values: transformations";
  rdfs:comment "If the supplied value of an array property is not an array (eg if it is an integer), compliant applications MUST issue a warning and proceed as if the property had been supplied with an empty array";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test099-metadata.json>;
  mf:result <test099.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test101 a csvt:ToRdfTest;
  mf:name "inconsistent array values: foreignKeys";
  rdfs:comment "If the supplied value of an array property is not an array (eg if it is an integer), compliant applications MUST issue a warning and proceed as if the property had been supplied with an empty array";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test101-metadata.json>;
  mf:result <test101.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test102 a csvt:ToRdfTest;
  mf:name "inconsistent link values: @id";
  rdfs:comment "If the supplied value of an array property is not an array (eg if it is an integer), compliant applications MUST issue a warning and proceed as if the property had been supplied with an empty array";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test102-metadata.json>;
  mf:result <test102.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test106 a csvt:ToRdfTest;
  mf:name "invalid dialect";
  rdfs:comment "If the supplied value of an object property is not a string or object (eg if it is an integer), compliant applications MUST issue a warning and proceed as if the property had been specified as an object with no properties.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test106-metadata.json>;
  mf:result <test106.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test109 a csvt:ToRdfTest;
  mf:name "titles with invalid language";
  rdfs:comment "Natural Language properties may be objects whose properties MUST be language codes as defined by [BCP47] and whose values are either strings or arrays, providing natural language strings in that language";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test109-metadata.json>;
  mf:result <test109.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test110 a csvt:ToRdfTest;
  mf:name "titles with non-string values";
  rdfs:comment "Natural Language properties may be objects whose properties MUST be language codes as defined by [BCP47] and whose values are either strings or arrays, providing natural language strings in that language";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test110-metadata.json>;
  mf:result <test110.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test111 a csvt:ToRdfTest;
  mf:name "titles with invalid value";
  rdfs:comment "If the supplied value of a natural language property is not a string, array or object (eg if it is an integer), compliant applications MUST issue a warning and proceed as if the property had been specified as an empty array";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test111-metadata.json>;
  mf:result <test111.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test112 a csvt:ToRdfTest;
  mf:name "titles with non-string array values";
  rdfs:comment "If the supplied value is an array, any items in that array that are not strings MUST be ignored";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test112-metadata.json>;
  mf:result <test112.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test113 a csvt:ToRdfTest;
  mf:name "invalid suppressOutput";
  rdfs:comment "Atomic properties: Processors MUST issue a warning if a property is set to an invalid value type";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test113-metadata.json>;
  mf:result <test113.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test114 a csvt:ToRdfTest;
  mf:name "invalid name";
  rdfs:comment "Atomic properties: Processors MUST issue a warning if a property is set to an invalid value type";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test114-metadata.json>;
  mf:result <test114.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test115 a csvt:ToRdfTest;
  mf:name "invalid virtual";
  rdfs:comment "Atomic properties: Processors MUST issue a warning if a property is set to an invalid value type";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test115-metadata.json>;
  mf:result <test115.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test116 a csvt:ToRdfTest;
  mf:name "file-metadata with query component";
  rdfs:comment "processors MUST attempt to locate a file-specific metadata document. This method MUST NOT be used if the URL of the tabular data file contains a query component.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test116.csv?query>;
  mf:result <test116.ttl>;
  csvt:implicit <test116.csv-metadata.json>;
  .

:test117 a csvt:ToRdfTest;
  mf:name "file-metadata not referencing file";
  rdfs:comment "If the metadata file found at this location does not explicitly include a reference to the requested tabular data file then it MUST be ignored.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test117.csv>;
  mf:result <test117.ttl>;
  csvt:implicit <test117.csv-metadata.json>;
  .

:test118 a csvt:ToRdfTest;
  mf:name "directory-metadata with query component";
  rdfs:comment "processors MUST attempt to locate a directory-level metadata document. This method MUST NOT be used if the URL of the tabular data file contains a query component.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test118/action.csv?query>;
  mf:result <test118/result.ttl>;
  csvt:implicit <test118/metadata.json>;
  .

:test119 a csvt:ToRdfTest;
  mf:name "directory-metadata not referencing file";
  rdfs:comment "If the metadata file found at this location does not explicitly include a reference to the requested tabular data file then it MUST be ignored.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test119/action.csv>;
  mf:result <test119/result.ttl>;
  csvt:implicit <test119/metadata.json>;
  .

:test120 a csvt:ToRdfTest;
  mf:name "link-metadata not referencing file";
  rdfs:comment "If the metadata file found at this location does not explicitly include a reference to the requested tabular data file then it MUST be ignored.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  csvt:httpLink "<test120-linked-metadata.json>; rel=\"describedby\"";
  mf:action <test120.csv>;
  mf:result <test120.ttl>;
  csvt:implicit <test120-linked-metadata.json>;
  .

:test121 a csvt:ToRdfTest;
  mf:name "user-metadata not referencing file";
  rdfs:comment "User-specified metadata does not need to reference the starting CSV";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:metadata <test121-user-metadata.json>;
  ];
  mf:action <test121.csv>;
  mf:result <test121.ttl>;
  csvt:implicit <test121-ref.csv>,
    <test121-user-metadata.json>;
  .

:test122 a csvt:ToRdfTest;
  mf:name "link-metadata not describing file uses file-metadata";
  rdfs:comment "If the metadata file found at this location does not explicitly include a reference to the requested tabular data file then it MUST be ignored.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  csvt:httpLink "<test122-linked-metadata.json>; rel=\"describedby\"";
  mf:action <test122.csv>;
  mf:result <test122.ttl>;
  csvt:implicit <test122-metadata.json>,
    <test122-linked-metadata.json>;
  .

:test123 a csvt:ToRdfTest;
  mf:name "file-metadata not describing file uses directory-metadata";
  rdfs:comment "If the metadata file found at this location does not explicitly include a reference to the requested tabular data file then it MUST be ignored.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test123/action.csv>;
  mf:result <test123/result.ttl>;
  csvt:implicit <test123/action.csv-metadata.json>,
    <test123/metadata.json>;
  .

:test124 a csvt:ToRdfTest;
  mf:name "metadata with columns not matching csv titles";
  rdfs:comment "If not validating, and one schema has a name property but not a titles property, and the other has a titles property but not a name property.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <tree-ops.csv>;
  mf:result <test124.ttl>;
  .

:test125 a csvt:ToRdfTest;
  mf:name "required column with empty cell";
  rdfs:comment "If the column required annotation is true, add an error to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test125-metadata.json>;
  mf:result <test125.ttl>;
  csvt:implicit <test125.csv>;
  .

:test126 a csvt:ToRdfTest;
  mf:name "required column with cell matching null";
  rdfs:comment "if the string is the same as any one of the values of the column null annotation, then the resulting value is null. If the column separator annotation is null and the column required annotation is true, add an error to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test126-metadata.json>;
  mf:result <test126.ttl>;
  csvt:implicit <test126.csv>;
  .

:test127 a csvt:ToRdfTest;
  mf:name "incompatible table";
  rdfs:comment "if TM is not compatible with EM validators MUST raise an error, other processors MUST generate a warning and continue processing";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test127-metadata.json>;
  mf:result <test127.ttl>;
  csvt:implicit <test127.csv>;
  .

:test129 a csvt:ToRdfTest;
  mf:name "columnn name as integer";
  rdfs:comment "This (name) MUST be a string and this property has no default value, which means it MUST be ignored if the supplied value is not a string.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test129-metadata.json>;
  mf:result <test129.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test130 a csvt:ToRdfTest;
  mf:name "invalid column name";
  rdfs:comment "column names are restricted as defined in Variables in [URI-TEMPLATE] ";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test130-metadata.json>;
  mf:result <test130.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test131 a csvt:ToRdfTest;
  mf:name "invalid column name";
  rdfs:comment "column names are restricted ... names beginning with '_' are reserved by this specification and MUST NOT be used within metadata documents.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test131-metadata.json>;
  mf:result <test131.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test132 a csvt:ToRdfTest;
  mf:name "name annotation from title percent encoded";
  rdfs:comment "If there is no name property defined on this column, the first titles value having the same language tag as default language, or und or if no default language is specified, becomes the name annotation for the described column. This annotation MUST be percent-encoded as necessary to conform to the syntactic requirements defined in [RFC3986]";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test132-metadata.json>;
  mf:result <test132.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test147 a csvt:ToRdfTest;
  mf:name "title incompatible with title on case";
  rdfs:comment "If there is a non-empty case-sensitive intersection between the titles values, where matches MUST have a matching language; `und` matches any language, and languages match if they are equal when truncated, as defined in [BCP47], to the length of the shortest language tag.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test147-metadata.json>;
  mf:result <test147.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test148 a csvt:ToRdfTest;
  mf:name "title incompatible with title on language";
  rdfs:comment "If there is a non-empty case-sensitive intersection between the titles values, where matches MUST have a matching language; `und` matches any language, and languages match if they are equal when truncated, as defined in [BCP47], to the length of the shortest language tag.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test148-metadata.json>;
  mf:result <test148.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test149 a csvt:ToRdfTest;
  mf:name "title compatible with title on less specific language";
  rdfs:comment "If there is a non-empty case-sensitive intersection between the titles values, where matches MUST have a matching language; `und` matches any language, and languages match if they are equal when truncated, as defined in [BCP47], to the length of the shortest language tag.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test149-metadata.json>;
  mf:result <test149.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test150 a csvt:ToRdfTest;
  mf:name "non-builtin datatype (datatype value)";
  rdfs:comment "If the value of this property is a string, it MUST be one of the built-in datatypes defined in section 5.11.1 Built-in Datatypes or an absolute URL";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test150-metadata.json>;
  mf:result <test150.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test151 a csvt:ToRdfTest;
  mf:name "non-builtin datatype (base value)";
  rdfs:comment "If the value of this property is a string, it MUST be one of the built-in datatypes";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test151-metadata.json>;
  mf:result <test151.ttl>;
  csvt:implicit <tree-ops.csv>;
  .

:test152 a csvt:ToRdfTest;
  mf:name "string format (valid combinations)";
  rdfs:comment "If the datatype base is not numeric, boolean, a date/time type, or a duration type, the datatype format annotation provides a regular expression for the string values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test152-metadata.json>;
  mf:result <test152.ttl>;
  csvt:implicit <test152.csv>;
  .

:test153 a csvt:NegativeRdfTest;
  mf:name "string format (bad format string)";
  rdfs:comment "If the datatype base is not numeric, boolean, a date/time type, or a duration type, the datatype format annotation provides a regular expression for the string values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test153-metadata.json>;
  csvt:implicit <test153.csv>;
  .

:test154 a csvt:ToRdfTest;
  mf:name "string format (value not matching format)";
  rdfs:comment "If the datatype base is not numeric, boolean, a date/time type, or a duration type, the datatype format annotation provides a regular expression for the string values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test154-metadata.json>;
  mf:result <test154.ttl>;
  csvt:implicit <test154.csv>;
  .

:test155 a csvt:ToRdfTest;
  mf:name "number format (valid combinations)";
  rdfs:comment "If the datatype format annotation is a single string, this is interpreted in the same way as if it were an object with a pattern property whose value is that string";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test155-metadata.json>;
  mf:result <test155.ttl>;
  csvt:implicit <test155.csv>;
  .

:test156 a csvt:NegativeRdfTest;
  mf:name "number format (bad format string)";
  rdfs:comment "If the datatype format annotation is a single string, this is interpreted in the same way as if it were an object with a pattern property whose value is that string";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test156-metadata.json>;
  csvt:implicit <test156.csv>;
  .

:test157 a csvt:ToRdfTest;
  mf:name "number format (value not matching format)";
  rdfs:comment "If the datatype format annotation is a single string, this is interpreted in the same way as if it were an object with a pattern property whose value is that string";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test157-metadata.json>;
  mf:result <test157.ttl>;
  csvt:implicit <test157.csv>;
  .

:test158 a csvt:ToRdfTest;
  mf:name "number format (valid combinations)";
  rdfs:comment "Numeric dataype with object format";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test158-metadata.json>;
  mf:result <test158.ttl>;
  csvt:implicit <test158.csv>;
  .

:test159 a csvt:NegativeRdfTest;
  mf:name "number format (bad pattern format string)";
  rdfs:comment "If the datatype format annotation is a single string, this is interpreted in the same way as if it were an object with a pattern property whose value is that string";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test159-metadata.json>;
  csvt:implicit <test159.csv>;
  .

:test160 a csvt:ToRdfTest;
  mf:name "number format (not matching values with pattern)";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell if the string being parsed";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test160-metadata.json>;
  mf:result <test160.ttl>;
  csvt:implicit <test160.csv>;
  .

:test161 a csvt:ToRdfTest;
  mf:name "number format (not matching values without pattern)";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell if the string being parsed";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test161-metadata.json>;
  mf:result <test161.ttl>;
  csvt:implicit <test161.csv>;
  .

:test162 a csvt:ToRdfTest;
  mf:name "numeric format (consecutive groupChar)";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell if the string being parsed contains two consecutive groupChar strings";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test162-metadata.json>;
  mf:result <test162.ttl>;
  csvt:implicit <test162.csv>;
  .

:test163 a csvt:ToRdfTest;
  mf:name "integer datatype with decimalChar";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell if the string being parsed contains the decimalChar, if the datatype base is integer or one of its sub-values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test163-metadata.json>;
  mf:result <test163.ttl>;
  csvt:implicit <test163.csv>;
  .

:test164 a csvt:ToRdfTest;
  mf:name "decimal datatype with exponent";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, if the datatype base is decimal or one of its sub-values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test164-metadata.json>;
  mf:result <test164.ttl>;
  csvt:implicit <test164.csv>;
  .

:test165 a csvt:ToRdfTest;
  mf:name "decimal type with NaN";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, is one of the special values NaN, INF, or -INF, if the datatype base is decimal or one of its sub-values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test165-metadata.json>;
  mf:result <test165.ttl>;
  csvt:implicit <test165.csv>;
  .

:test166 a csvt:ToRdfTest;
  mf:name "decimal type with INF";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, is one of the special values NaN, INF, or -INF, if the datatype base is decimal or one of its sub-values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test166-metadata.json>;
  mf:result <test166.ttl>;
  csvt:implicit <test166.csv>;
  .

:test167 a csvt:ToRdfTest;
  mf:name "decimal type with -INF";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, is one of the special values NaN, INF, or -INF, if the datatype base is decimal or one of its sub-values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test167-metadata.json>;
  mf:result <test167.ttl>;
  csvt:implicit <test167.csv>;
  .

:test168 a csvt:ToRdfTest;
  mf:name "decimal with implicit groupChar";
  rdfs:comment "When parsing the string value of a cell against this format specification, implementations MUST recognise and parse numbers";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test168-metadata.json>;
  mf:result <test168.ttl>;
  csvt:implicit <test168.csv>;
  .

:test169 a csvt:ToRdfTest;
  mf:name "invalid decimal";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test169-metadata.json>;
  mf:result <test169.ttl>;
  csvt:implicit <test169.csv>;
  .

:test170 a csvt:ToRdfTest;
  mf:name "decimal with percent";
  rdfs:comment "Implementations MUST use the sign, exponent, percent, and per-mille signs when parsing the string value of a cell to provide the value of the cell";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test170-metadata.json>;
  mf:result <test170.ttl>;
  csvt:implicit <test170.csv>;
  .

:test171 a csvt:ToRdfTest;
  mf:name "decimal with per-mille";
  rdfs:comment "Implementations MUST use the sign, exponent, percent, and per-mille signs when parsing the string value of a cell to provide the value of the cell";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test171-metadata.json>;
  mf:result <test171.ttl>;
  csvt:implicit <test171.csv>;
  .

:test172 a csvt:ToRdfTest;
  mf:name "invalid byte";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test172-metadata.json>;
  mf:result <test172.ttl>;
  csvt:implicit <test172.csv>;
  .

:test173 a csvt:ToRdfTest;
  mf:name "invald unsignedLong";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test173-metadata.json>;
  mf:result <test173.ttl>;
  csvt:implicit <test173.csv>;
  .

:test174 a csvt:ToRdfTest;
  mf:name "invalid unsignedShort";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test174-metadata.json>;
  mf:result <test174.ttl>;
  csvt:implicit <test174.csv>;
  .

:test175 a csvt:ToRdfTest;
  mf:name "invalid unsignedByte";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test175-metadata.json>;
  mf:result <test175.ttl>;
  csvt:implicit <test175.csv>;
  .

:test176 a csvt:ToRdfTest;
  mf:name "invalid positiveInteger";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test176-metadata.json>;
  mf:result <test176.ttl>;
  csvt:implicit <test176.csv>;
  .

:test177 a csvt:ToRdfTest;
  mf:name "invalid negativeInteger";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test177-metadata.json>;
  mf:result <test177.ttl>;
  csvt:implicit <test177.csv>;
  .

:test178 a csvt:ToRdfTest;
  mf:name "invalid nonPositiveInteger";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test178-metadata.json>;
  mf:result <test178.ttl>;
  csvt:implicit <test178.csv>;
  .

:test179 a csvt:ToRdfTest;
  mf:name "invalid nonNegativeInteger";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test179-metadata.json>;
  mf:result <test179.ttl>;
  csvt:implicit <test179.csv>;
  .

:test180 a csvt:ToRdfTest;
  mf:name "invalid double";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test180-metadata.json>;
  mf:result <test180.ttl>;
  csvt:implicit <test180.csv>;
  .

:test181 a csvt:ToRdfTest;
  mf:name "invalid number";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test181-metadata.json>;
  mf:result <test181.ttl>;
  csvt:implicit <test181.csv>;
  .

:test182 a csvt:ToRdfTest;
  mf:name "invalid float";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell contains an exponent, does not meet the numeric format defined above";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test182-metadata.json>;
  mf:result <test182.ttl>;
  csvt:implicit <test182.csv>;
  .

:test183 a csvt:ToRdfTest;
  mf:name "boolean format (valid combinations)";
  rdfs:comment "If the datatype base for a cell is boolean, the datatype format annotation provides the true and false values expected, separated by `|`.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test183-metadata.json>;
  mf:result <test183.ttl>;
  csvt:implicit <test183.csv>;
  .

:test184 a csvt:NegativeRdfTest;
  mf:name "boolean format (bad format string)";
  rdfs:comment "If the datatype base for a cell is boolean, the datatype format annotation provides the true and false values expected, separated by `|`.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test184-metadata.json>;
  csvt:implicit <test184.csv>;
  .

:test185 a csvt:ToRdfTest;
  mf:name "boolean format (value not matching format)";
  rdfs:comment "If the datatype base for a cell is boolean, the datatype format annotation provides the true and false values expected, separated by `|`.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test185-metadata.json>;
  mf:result <test185.ttl>;
  csvt:implicit <test185.csv>;
  .

:test186 a csvt:ToRdfTest;
  mf:name "boolean format (not matching datatype)";
  rdfs:comment "Implementations MUST add a validation error to the errors annotation for the cell if the string being parsed";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test186-metadata.json>;
  mf:result <test186.ttl>;
  csvt:implicit <test186.csv>;
  .

:test187 a csvt:ToRdfTest;
  mf:name "date format (valid native combinations)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test187-metadata.json>;
  mf:result <test187.ttl>;
  csvt:implicit <test187.csv>;
  .

:test188 a csvt:ToRdfTest;
  mf:name "date format (valid date combinations with formats)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test188-metadata.json>;
  mf:result <test188.ttl>;
  csvt:implicit <test188.csv>;
  .

:test189 a csvt:ToRdfTest;
  mf:name "date format (valid time combinations with formats)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test189-metadata.json>;
  mf:result <test189.ttl>;
  csvt:implicit <test189.csv>;
  .

:test190 a csvt:ToRdfTest;
  mf:name "date format (valid dateTime combinations with formats)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test190-metadata.json>;
  mf:result <test190.ttl>;
  csvt:implicit <test190.csv>;
  .

:test191 a csvt:NegativeRdfTest;
  mf:name "date format (bad format string)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test191-metadata.json>;
  csvt:implicit <test191.csv>;
  .

:test192 a csvt:ToRdfTest;
  mf:name "date format (value not matching format)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test192-metadata.json>;
  mf:result <test192.ttl>;
  csvt:implicit <test192.csv>;
  .

:test193 a csvt:ToRdfTest;
  mf:name "duration format (valid combinations)";
  rdfs:comment "If the datatype base is a duration type, the datatype format annotation provides a regular expression for the string values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test193-metadata.json>;
  mf:result <test193.ttl>;
  csvt:implicit <test193.csv>;
  .

:test194 a csvt:ToRdfTest;
  mf:name "duration format (value not matching format)";
  rdfs:comment "If the datatype base is a duration type, the datatype format annotation provides a regular expression for the string values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test194-metadata.json>;
  mf:result <test194.ttl>;
  csvt:implicit <test194.csv>;
  .

:test195 a csvt:ToRdfTest;
  mf:name "values with matching length";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test195-metadata.json>;
  mf:result <test195.ttl>;
  csvt:implicit <test195.csv>;
  .

:test196 a csvt:ToRdfTest;
  mf:name "values with wrong length";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test196-metadata.json>;
  mf:result <test196.ttl>;
  csvt:implicit <test196.csv>;
  .

:test197 a csvt:ToRdfTest;
  mf:name "values with wrong maxLength";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test197-metadata.json>;
  mf:result <test197.ttl>;
  csvt:implicit <test197.csv>;
  .

:test198 a csvt:ToRdfTest;
  mf:name "values with wrong minLength";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test198-metadata.json>;
  mf:result <test198.ttl>;
  csvt:implicit <test198.csv>;
  .

:test199 a csvt:NegativeRdfTest;
  mf:name "length != minLength";
  rdfs:comment "Applications MUST raise an error if both length and minLength are specified and they do not have the same value. ";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test199-metadata.json>;
  csvt:implicit <test199.csv>;
  .

:test200 a csvt:NegativeRdfTest;
  mf:name "length != maxLength";
  rdfs:comment "Applications MUST raise an error if both length and maxLength are specified and they do not have the same value. ";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test200-metadata.json>;
  csvt:implicit <test200.csv>;
  .

:test201 a csvt:NegativeRdfTest;
  mf:name "length on date";
  rdfs:comment "Applications MUST raise an error if length, maxLength, or minLength are specified and the base datatype is not string or one of its subtypes, or a binary type.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test201-metadata.json>;
  csvt:implicit <test201.csv>;
  .

:test202 a csvt:ToRdfTest;
  mf:name "float matching constraints";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test202-metadata.json>;
  mf:result <test202.ttl>;
  csvt:implicit <test202.csv>;
  .

:test203 a csvt:ToRdfTest;
  mf:name "float value constraint not matching minimum";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test203-metadata.json>;
  mf:result <test203.ttl>;
  csvt:implicit <test203.csv>;
  .

:test204 a csvt:ToRdfTest;
  mf:name "float value constraint not matching maximum";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test204-metadata.json>;
  mf:result <test204.ttl>;
  csvt:implicit <test204.csv>;
  .

:test205 a csvt:ToRdfTest;
  mf:name "float value constraint not matching minInclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test205-metadata.json>;
  mf:result <test205.ttl>;
  csvt:implicit <test205.csv>;
  .

:test206 a csvt:ToRdfTest;
  mf:name "float value constraint not matching minExclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test206-metadata.json>;
  mf:result <test206.ttl>;
  csvt:implicit <test206.csv>;
  .

:test207 a csvt:ToRdfTest;
  mf:name "float value constraint not matching maxInclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test207-metadata.json>;
  mf:result <test207.ttl>;
  csvt:implicit <test207.csv>;
  .

:test208 a csvt:ToRdfTest;
  mf:name "float value constraint not matching maxExclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test208-metadata.json>;
  mf:result <test208.ttl>;
  csvt:implicit <test208.csv>;
  .

:test209 a csvt:ToRdfTest;
  mf:name "date matching constraints";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test209-metadata.json>;
  mf:result <test209.ttl>;
  csvt:implicit <test209.csv>;
  .

:test210 a csvt:ToRdfTest;
  mf:name "date value constraint not matching minimum";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test210-metadata.json>;
  mf:result <test210.ttl>;
  csvt:implicit <test210.csv>;
  .

:test211 a csvt:ToRdfTest;
  mf:name "date value constraint not matching maximum";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test211-metadata.json>;
  mf:result <test211.ttl>;
  csvt:implicit <test211.csv>;
  .

:test212 a csvt:ToRdfTest;
  mf:name "date value constraint not matching minInclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test212-metadata.json>;
  mf:result <test212.ttl>;
  csvt:implicit <test212.csv>;
  .

:test213 a csvt:ToRdfTest;
  mf:name "date value constraint not matching minExclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test213-metadata.json>;
  mf:result <test213.ttl>;
  csvt:implicit <test213.csv>;
  .

:test214 a csvt:ToRdfTest;
  mf:name "date value constraint not matching maxInclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test214-metadata.json>;
  mf:result <test214.ttl>;
  csvt:implicit <test214.csv>;
  .

:test215 a csvt:ToRdfTest;
  mf:name "date value constraint not matching maxExclusive";
  rdfs:comment "validate the value based on the length constraints described in section 4.6.1 Length Constraints, the value constraints described in section 4.6.2 Value Constraints and the datatype format annotation if one is specified, as described below. If there are any errors, add them to the list of errors for the cell.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test215-metadata.json>;
  mf:result <test215.ttl>;
  csvt:implicit <test215.csv>;
  .

:test216 a csvt:NegativeRdfTest;
  mf:name "minInclusive and minExclusive";
  rdfs:comment "Applications MUST raise an error if both minInclusive and minExclusive are specified, or if both maxInclusive and maxExclusive are specified. ";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test216-metadata.json>;
  csvt:implicit <test216.csv>;
  .

:test217 a csvt:NegativeRdfTest;
  mf:name "maxInclusive and maxExclusive";
  rdfs:comment "Applications MUST raise an error if both minInclusive and minExclusive are specified, or if both maxInclusive and maxExclusive are specified. ";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test217-metadata.json>;
  csvt:implicit <test217.csv>;
  .

:test218 a csvt:NegativeRdfTest;
  mf:name "maxInclusive < minInclusive";
  rdfs:comment "Applications MUST raise an error if both minInclusive and maxInclusive are specified and maxInclusive is less than minInclusive, or if both minInclusive and maxExclusive are specified and maxExclusive is less than or equal to minInclusive.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test218-metadata.json>;
  csvt:implicit <test218.csv>;
  .

:test219 a csvt:NegativeRdfTest;
  mf:name "maxExclusive = minInclusive";
  rdfs:comment "Applications MUST raise an error if both minInclusive and maxInclusive are specified and maxInclusive is less than minInclusive, or if both minInclusive and maxExclusive are specified and maxExclusive is less than or equal to minInclusive.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test219-metadata.json>;
  csvt:implicit <test219.csv>;
  .

:test220 a csvt:NegativeRdfTest;
  mf:name "maxExclusive < minExclusive";
  rdfs:comment "Applications MUST raise an error if both minExclusive and maxExclusive are specified and maxExclusive is less than minExclusive, or if both minExclusive and maxInclusive are specified and maxInclusive is less than or equal to minExclusive.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test220-metadata.json>;
  csvt:implicit <test220.csv>;
  .

:test221 a csvt:NegativeRdfTest;
  mf:name "maxInclusive = minExclusive";
  rdfs:comment "Applications MUST raise an error if both minExclusive and maxExclusive are specified and maxExclusive is less than minExclusive, or if both minExclusive and maxInclusive are specified and maxInclusive is less than or equal to minExclusive.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test221-metadata.json>;
  csvt:implicit <test221.csv>;
  .

:test222 a csvt:NegativeRdfTest;
  mf:name "string datatype with minimum";
  rdfs:comment "Applications MUST raise an error if minimum, minInclusive, maximum, maxInclusive, minExclusive, or maxExclusive are specified and the base datatype is not a numeric, date/time, or duration type.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test222-metadata.json>;
  csvt:implicit <test222.csv>;
  .

:test223 a csvt:NegativeRdfTest;
  mf:name "string datatype with maxium";
  rdfs:comment "Applications MUST raise an error if minimum, minInclusive, maximum, maxInclusive, minExclusive, or maxExclusive are specified and the base datatype is not a numeric, date/time, or duration type.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test223-metadata.json>;
  csvt:implicit <test223.csv>;
  .

:test224 a csvt:NegativeRdfTest;
  mf:name "string datatype with minInclusive";
  rdfs:comment "Applications MUST raise an error if minimum, minInclusive, maximum, maxInclusive, minExclusive, or maxExclusive are specified and the base datatype is not a numeric, date/time, or duration type.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test224-metadata.json>;
  csvt:implicit <test224.csv>;
  .

:test225 a csvt:NegativeRdfTest;
  mf:name "string datatype with maxInclusive";
  rdfs:comment "Applications MUST raise an error if minimum, minInclusive, maximum, maxInclusive, minExclusive, or maxExclusive are specified and the base datatype is not a numeric, date/time, or duration type.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test225-metadata.json>;
  csvt:implicit <test225.csv>;
  .

:test226 a csvt:NegativeRdfTest;
  mf:name "string datatype with minExclusive";
  rdfs:comment "Applications MUST raise an error if minimum, minInclusive, maximum, maxInclusive, minExclusive, or maxExclusive are specified and the base datatype is not a numeric, date/time, or duration type.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test226-metadata.json>;
  csvt:implicit <test226.csv>;
  .

:test227 a csvt:NegativeRdfTest;
  mf:name "string datatype with maxExclusive";
  rdfs:comment "Applications MUST raise an error if minimum, minInclusive, maximum, maxInclusive, minExclusive, or maxExclusive are specified and the base datatype is not a numeric, date/time, or duration type.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test227-metadata.json>;
  csvt:implicit <test227.csv>;
  .

:test228 a csvt:ToRdfTest;
  mf:name "length with separator";
  rdfs:comment "If the value is a list, the constraint applies to each element of the list.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test228-metadata.json>;
  mf:result <test228.ttl>;
  csvt:implicit <test228.csv>;
  .

:test229 a csvt:ToRdfTest;
  mf:name "matching minLength with separator";
  rdfs:comment "If the value is a list, the constraint applies to each element of the list.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test229-metadata.json>;
  mf:result <test229.ttl>;
  csvt:implicit <test229.csv>;
  .

:test230 a csvt:ToRdfTest;
  mf:name "failing minLength with separator";
  rdfs:comment "If the value is a list, the constraint applies to each element of the list.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test230-metadata.json>;
  mf:result <test230.ttl>;
  csvt:implicit <test230.csv>;
  .

:test231 a csvt:ToRdfTest;
  mf:name "single column primaryKey success";
  rdfs:comment "As defined in [tabular-data-model], validators MUST check that each row has a unique combination of values of cells in the indicated columns.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test231-metadata.json>;
  mf:result <test231.ttl>;
  csvt:implicit <test231.csv>;
  .

:test232 a csvt:ToRdfTest;
  mf:name "single column primaryKey violation";
  rdfs:comment "As defined in [tabular-data-model], validators MUST check that each row has a unique combination of values of cells in the indicated columns.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test232-metadata.json>;
  mf:result <test232.ttl>;
  csvt:implicit <test232.csv>;
  .

:test233 a csvt:ToRdfTest;
  mf:name "multiple column primaryKey success";
  rdfs:comment "As defined in [tabular-data-model], validators MUST check that each row has a unique combination of values of cells in the indicated columns.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test233-metadata.json>;
  mf:result <test233.ttl>;
  csvt:implicit <test233.csv>;
  .

:test234 a csvt:ToRdfTest;
  mf:name "multiple column primaryKey violation";
  rdfs:comment "As defined in [tabular-data-model], validators MUST check that each row has a unique combination of values of cells in the indicated columns.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test234-metadata.json>;
  mf:result <test234.ttl>;
  csvt:implicit <test234.csv>;
  .

:test235 a csvt:ToRdfTest;
  mf:name "rowTitles on one column";
  rdfs:comment "if row titles is not null, insert any titles specified for the row. For each value, tv, of the row titles annotation";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test235-metadata.json>;
  mf:result <test235.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test236 a csvt:ToRdfTest;
  mf:name "rowTitles on multiple columns";
  rdfs:comment "if row titles is not null, insert any titles specified for the row. For each value, tv, of the row titles annotation";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test236-metadata.json>;
  mf:result <test236.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test237 a csvt:ToRdfTest;
  mf:name "rowTitles on one column (minimal)";
  rdfs:comment "if row titles is not null, insert any titles specified for the row. For each value, tv, of the row titles annotation";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
    csvt:minimal true;
  ];
  mf:action <test237-metadata.json>;
  mf:result <test237.ttl>;
  csvt:implicit <countries.csv>,
    <country_slice.csv>;
  .

:test238 a csvt:ToRdfTest;
  mf:name "datatype value an absolute URL";
  rdfs:comment "it must be the name of one of the built-in datatypes defined in section 5.11.1 Built-in Datatypes";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test238-metadata.json>;
  mf:result <test238.ttl>;
  csvt:implicit <test238.csv>;
  .

:test242 a csvt:ToRdfTest;
  mf:name "datatype @id an absolute URL";
  rdfs:comment "If included, @id is a link property that identifies the datatype described by this datatype description.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test242-metadata.json>;
  mf:result <test242.ttl>;
  csvt:implicit <test242.csv>;
  .

:test243 a csvt:NegativeRdfTest;
  mf:name "invalid datatype @id";
  rdfs:comment "It MUST NOT start with `_:`.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test243-metadata.json>;
  csvt:implicit <test243.csv>;
  .

:test244 a csvt:NegativeRdfTest;
  mf:name "invalid datatype @id";
  rdfs:comment "It MUST NOT be the URL of a built-in datatype.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test244-metadata.json>;
  csvt:implicit <test244.csv>;
  .

:test245 a csvt:ToRdfTest;
  mf:name "date format (valid time combinations with formats and milliseconds)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test245-metadata.json>;
  mf:result <test245.ttl>;
  csvt:implicit <test245.csv>;
  .

:test246 a csvt:ToRdfTest;
  mf:name "date format (valid dateTime combinations with formats and milliseconds)";
  rdfs:comment "The supported date and time formats listed here are expressed in terms of the date field symbols defined in [UAX35] and MUST be interpreted by implementations as defined in that specification.";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test246-metadata.json>;
  mf:result <test246.ttl>;
  csvt:implicit <test246.csv>;
  .

:test247 a csvt:ToRdfTest;
  mf:name "date format (extra milliseconds)";
  rdfs:comment "it must be the name of one of the built-in datatypes defined in section 5.11.1 Built-in Datatypes";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test247-metadata.json>;
  mf:result <test247.ttl>;
  csvt:implicit <test247.csv>;
  .

:test248 a csvt:ToRdfTest;
  mf:name "Unicode in non-Normalized form";
  rdfs:comment "No Unicode normalization (as specified in [UAX15]) is applied to these string values";
  rdft:approval rdft:Proposed;
  csvt:option [
    csvt:noProv true;
  ];
  mf:action <test248-metadata.json>;
  mf:result <test248.ttl>;
  csvt:implicit <test248.csv>;
  .
