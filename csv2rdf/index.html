<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <meta content="width=device-width,initial-scale=1" name="viewport">
    <title>Generating RDF from Tabular Data on the Web</title>
    <script class="remove" src="http://www.w3.org/Tools/respec/respec-w3c-common">
	  </script>
    <script class="remove">
var respecConfig = {
    localBiblio: {
    //     "EBNF-NOTATION": "Tim Bray; Jean Paoli; C. M. Sperberg-McQueen; Eve Maler; François Yergeau. <a href=\"http://www.w3.org/TR/REC-xml/#sec-notation\"><cite>EBNF Notation</cite></a> 26 November 2008. W3C Recommendation. URL: <a href=\"http://www.w3.org/TR/REC-xml/#sec-notation\">http://www.w3.org/TR/REC-xml/#sec-notation</a>"
    "RFC6570": "J. Gregorio; R. Fielding; M. Hadley; M. Nottingham; D. Orchard <a href=\"http://tools.ietf.org/html/rfc6570\"><cite>URI Template</cite></a> March 2012. Proposed Internet RFC 3987. URL: <a href=\"http://tools.ietf.org/html/rfc6570\">http://tools.ietf.org/html/rfc6570</a>",
    "tabular-data-model": "J. Tennison; G. Kellogg; <a href=\"http://www.w3.org/TR/tabular-data-model/\"><cite>Model for Tabular Data and Metadata on the Web</cite></a>, 16 May 2014. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/2014/WD-tabular-data-model-20140327/\">http://www.w3.org/TR/2014/WD-tabular-data-model-20140327/</a>. Editor's Draft: <a href=\"http://w3c.github.io/csvw/syntax/\">http://w3c.github.io/csvw/syntax/</a>.",
    "tabular-metadata": "R. Pollock; J. Tennison; <a href=\"http://w3c.github.io/csvw/metadata/\"><cite>Metadata Vocabulary for Tabular Data</cite></a>, 16 May 2014. W3C Editor's Draft. URL: <a href=\"http://w3c.github.io/csvw/metadata/\">http://w3c.github.io/csvw/metadata/</a>. "
  
    },
    specStatus: "ED",
    shortName: "csv2rdf",
    // publishDate:  "2014-04-01",
    previousPublishDate: "2014-??-??",
    previousMaturity: "unoffical",
    //previousURI: "http://www.w3.org/TR/2014/WD-csv2rdf-2014????/",
    edDraftURI: "http://w3c.github.io/csvw/csv2rdf/",
    // lcEnd: "3000-01-01",
    // crEnd: "3000-01-01",
    editors:
     [{
       name: "Andy Seaborne"
       , company: "Apache Software Foundation"
       , companyURL: ""
     }, { 
       name: "Gregg Kellogg", 
       url: "http://greggkellogg.net/",
       company: "Kellogg Associates", 
       companyURL: "http://kellogg-assoc.com/" 
     }, {
       name: "Ivan Herman",
       url: "http://www.w3.org/People/Ivan",
       company: "W3C",
       companyURL: "http://www.w3.org"
     }],
    wg: "CSV on the Web Working Group",
    wgURI: "http://www.w3.org/2013/csvw/",
    wgPublicList: "public-csv-wg",
    wgPatentURI: "http://www.w3.org/2004/01/pp-impl/68238/status",
    otherLinks: [{
      key: "Repository",
      data: [{
          value: "We are on Github",
          href: "https://github.com/w3c/csvw/"
        }, {
          value: "File a bug",
          href: "https://github.com/w3c/csvw/issues"
        }]
      } , 
      {
        key: "Changes",
        data: [{
        //     value: "Diff to previous version",
        //     href: "diff-20140327.html"
        //   }, {}
           value: "Commit history",
           href: "https://github.com/w3c/csvw/commits/gh-pages"
         }]
       }] ,
    inlineCSS: true,
    noIDLIn: true,
    noLegacyStyle: false
    };
    </script>
    <style type="text/css">
      .grammar td { font-family: monospace; vertical-align: top; }
      .grammar-literal { color: gray;}
      .TBD { font-style: italic; background: yellow;}
    </style>
  </head>
  <body>
    <section id="abstract">
      <p> T.B.D.</p>
    </section>
    <section id="sotd">
      <p> <em>Work-in-progress.</em> </p>
    </section>
    <section id="intro">
      <h2>Introduction</h2>
      <p> <dfn title="tabular data">Tabular data</dfn> is data that is
        structured into rows, each of which contains information about some
        thing. Each row contains the same number of fields (although some of
        these fields may be empty), which provide values of properties of the
        thing described by the row. In tabular data, fields within the same
        column provide values for the same property of the thing described by
        the particular row. This is what differentiates tabular data from other
        line-oriented formats. </p>
      <p> One common form of Tabular Data is CSV RFC [[!RFC4180]] (to be
        revised). </p>
      <p>This document describes the processing of Tabular Data
        [[!tabular-data-model]] to produce RDF [[!rdf11-concepts]]. It does not
        cover any cleaning or trasnformation processes needed to convert the
        initial data into Tabular Data form. Tabular Data defines an abstract
        data model considitng of tables, columns, header rows and data rows. It
        requires all rows to have the same number of columns. As such, Tabular
        Data does not cover all possible CSV files and ths processes described
        in this document do not apply to all possible CSV files. </p>
    </section>
    <section id="conformance">
      <p>This document describes the processing of Tabular Data
        [[!tabular-data-model]] to produce RDF [[!rdf11-concepts]]. It does not
        cover any cleaning or transformation processes needed to convert the
        initial data into Tabular Data form. Tabular Data defines an abstract
        data model consisting of <dfn title="table">tables</dfn>, <dfn title="column">columns</dfn>, 
        possible <dfn title="header row">header rows</dfn> providing <dfn title="name">column names</dfn>,
        and <dfn title="row">data rows</dfn>. 
        Each row consists of a number of <dfn title="field">fields</dfn>. It
        requires all rows to have the same number of columns. The specification
        relies on the terms (e.g, header, row, column) as defined
        in&nbsp;[[!tabular-data-model]].</p>
      <p>This specification makes use of the <dfn title="CURIE">CURIE Syntax</dfn> for describing RDF
        Triples; see, for example, the <a href="http://www.w3.org/TR/rdfa-core/#s_curies">CURIE
          Syntax Definition Section</a> of the RDFa 1.1 Core Specification
        [[!rdfa-core]].</p>
      <p>This specification makes use of the following namespaces:</p>
      <dl>
        <dt><code>csvw</code>:</dt>
        <dd><code>http://www.w3.org/ns/csvw#</code></dd>
        <dt><code>rdf</code>:</dt>
        <dd><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></dd>
        <dt><code>xsd</code>:</dt>
        <dd><code>http://www.w3.org/2001/XMLSchema#</code></dd>
        <dt><code>dc</code>:</dt>
        <dd><code>http://purl.org/dc/terms/</code></dd>
      </dl>
    </section>
    <section id="processing-tabular">
      <h2>Processing Annotated Tabular Data</h2>

      <p>The processing of tabular data is based on the abstract
         <a href="http://www.w3.org/TR/tabular-data-model/#annotated-model"><em>Annotated Tabular Data</em></a> 
         format as defined in&nbsp;[[!tabular-data-model]]. It does not cover any details on how the initial data (i.e., a CSV file) is
        parsed into one of those abstract Data formats. The processing steps below define the generated RDF [[!rdf11-concepts]]
        triples in a serialization-syntax independent way.</p>
 
      <p>Processing makes use of the metadata associated with the tabular data, and defined in the "Metadata
        Vocabulary for Tabular Data" [[!tabular-metadata]] document. In this section the term <dfn>property</dfn>&nbsp;
        refers to the properties defined in that document.</p>

      <p>The metadata for the tabular data may originate from <a href="http://www.w3.org/TR/tabular-data-model/#embedded-metadata">embedded metadata</a> only. In practice this means that the <a title="name">column names</a> are provided by a <a title="header row">header row</a>, but no other
      metadata is provided in the format described in [[!tabular-metadata]]. In that case, for the purpose of this section, processing begins by
      (virtually) providing metadata of the format:</p>

     <pre>[{
  "@id": "<em>URI of the CSV file</em>",
  "columns": [{
    "name": "<em>name<sub>1</sub></em>",
   }, 
   {
    "name": "<em>name<sub>2</sub></em>",
   }, 
   .
   .
   .
   {
    "name": "<em>name<sub>k</sub></em>",
  }]
}]</pre>
    <p>Where <code>name<sub>1</sub></code>, <code>name<sub>1</sub></code>,…,<code>name<sub>k</sub></code> are the names of the columns.</p> 
     

      <p>This section uses the value of the (required) <code>@id</code>
        property, expanded with <code>#</code>, as the default namespace.
        I.e., if the value of the <code>@id</code> property is <code>http://www.example.org/tree-ops.csv</code>,
        then <code>:name</code> is the CURIE abbreviation for <code>http://www.example.org/tree-ops.csv#name</code>.</p>
      <p>The processing steps are separated in the generation of table-level
        RDF triples, and row level RDF triples.</p>
      <section id="processing-steps-annotated-table">
        <h4>Processing Steps for Table-Level RDF triples</h4>
        <p>The following RDF triples are generated as table level triples:</p>
        <ul>
          <li>If the <code>@type</code> <a>property</a> is set:
            <ul>
              <li> If the value <code>C</code> of the <code>@type</code>
                property is an IRI, generate <br>
                <code>(@id rdf:type C)</code><br>
              </li>
              <li> otherwise, generate <br>
                <code>(@id rdf:type :C)</code> </li>
            </ul>
          </li>
          <li> For each (optional) <a>property</a> <code>prop<sub>i</sub></code>, corresponding to a term defined in [[!DC-TERMS]], 
            add the triple 
            <br><code>(@id dc:prop<sub>i</sub> value<sub>i</sub>)</code><br>
            where <code>value<sub>i</sub></code> is the value of the <code>prop<sub>i</sub></code>.
          </li>
        </ul>
      </section>
      <section id="processing-steps-annotated-table">
        <h4>Processing Steps for Field-Level RDF triples</h4>
        <ul>
          <li> The metadata specification in [[!tabular-metadata]] requires the presence of the <code>name</code>
            <a>property</a> for each <a>column</a>. For each of those names, a corresponding
            IRI (referred to hereafter as <code>C<sub>i</sub></code>) is defined as follows:
            <ul>
              <li>If the i<sup>th</sup> column descriptor metadata includes
                the <code>column-template</code> <a>property</a> then the
                corresponding template rules are used to generate <code>C<sub>i</sub></code>.</li>
              <li>Otherwise, <code>C<sub>i</sub></code> is set using the <em>normalized
                  version</em> of <a>name</a> as a <a>CURIE</a> reference
                combined with the default namespace (normalization means
                adding the necessary escape characters to <a>name</a> to
                make the CURIE expansion a valid URI)</li>
            </ul>
          </li>
          <li> For each <a>row</a> "j", a common
            <code>subject<sub>j</sub></code> is established as follows:
            <ul>
              <li> If the metadata specifies a primary key via a <code>primaryKey</code>
                property, then:
                <ul>
                  <li>If the primary key is a single column <code>name</code>,
                    then <code>subject<sub>j</sub> = :name</code></li>
                  <li>otherwise, <code>subject<sub>j</sub> = :name<sub>1</sub>-name<sub>2</sub>-…-name<sub>k</sub></code>,
                    where <code>name<sub>1</sub></code>, <code>name<sub>2</sub></code>,
                    …, <code>name<sub>k</sub></code> are the column names
                    listed as primary key values.</li>
                </ul>
              </li>
              <li>Otherwise <code>subject<sub>j</sub></code> is set to a
                newly generated blank node, as
                defined in [[!rdf11-concepts]]. </li>
            </ul>
          </li>
          <li>For <a>row</a> "j", the following RDF triple is generated: <br>
            <code>(subject<sub>j</sub> csvw:row "j"^^xsd:integer)</code></li>
          <li> For each <a>field</a> "i" in row "j", the value of <code>object<sub>i</sub></code>
            is established as follows:
            <ul>
              <li>If the i<sup>th</sup> column is defined as a foreign key via
                the <code>foreignKeys</code> property, <code>object<sub>i</sub></code>
                is set to the IRI defined for the foreign key <span class="TBD">(This is sketchy...)</span>. </li>
              <li>Otherwise, if the i<sup>th</sup> column descriptor metadata
                includes the <code>type</code> property, then <code>object<sub>i</sub></code>
                is the literal value of the field with the corresponding XSD
                datatype [[!xmlschema11-2]]. Note that this may require a
                transformation of the field to abide to the lexical form rules
                of the corresponding XSD datatype (e.g., for dates)</li>
              <li>Otherwise, if the i<sup>th</sup> column descriptor metadata
                includes the <code>field-template</code> property, then the
                corresponding template rules are used to generate the final
                object value. If the i<sup>th</sup> column descriptor metadata
                includes the <code>rdf-predicate-type</code> property with a
                value <code>object</code>, then <code>object<sub>i</sub></code>
                is an IRI reference; otherwise, it is an RDF Literal of type <code>xsd:string</code>
                with the generated value as lexical form.</li>
              <li>Otherwise, if the i<sup>th</sup> column descriptor metadata
                includes the <code>language</code> property, then <code>object<sub>i</sub></code>
                is an RDF literal with a language tag; the latter is set to
                the value of the <code>language</code> property.</li>
              <li>Otherwise, <code>object<sub>i</sub></code> is an RDF
                Literal of type <code>xsd:string</code> with the value of the
                field as lexical form.</li>
            </ul>
            Once the value of <code>object<sub>j</sub></code> established,
            the following triple is generated: <br>
            <code>(subject<sub>j</sub> C<sub>j</sub> object<sub>i</sub>)</code>
          </li>
        </ul>

        <div class="issue">The exact mapping to Dublin Core is underspecified; not sure how much details we want to put here.</div>

        <div class="issue">Some of the metadata, e.g., description of columns, are lost. Maybe it is worth adding a separate set of triples that collects those</div>

        <div class="issue">The algorithm, at present, generates triples for fields that are, in fact, primary keys (or parts of primary keys). Is that necessary, or should those triples be skipped?</div>

        <div class="issue">Do we need to add a set of triples that "bind" the graph as a whole to the resources describing individual rows? Ie, something like <code>(@id csvw:rowid subject<sub>i</sub></code> for each row? It may not be really necessary for RDF, but it may become necessary if we follow the same structure for JSON and want to have a close connection between JSON and JSON-LD; as far as I can see the latter would require a <code>@graph</code> keyword…</div>

        <div class="issue">It is not clear whether the value of <code>csvw:row</code> should take into account the header row, or should refer to
        the data rows only.</div>

        <div class="issue">Should there be a separate <code>rdf-skip</code> property for a column, instructing the processor to 'skip' that particular field?</div>

        <div class="issue">The current terminology for templates refer to them as format independent. Should there be a separate, <code>rdf-template</code> property that is to be used for RDF only (and only if there is no <code>template</code> property)?</div>


      </section>
    </section>

     <section id="processing-core">
      <h2>Processing Core Tabular Data</h2>
      <p>The <a href="http://www.w3.org/TR/tabular-data-model/#core-model"><em>Core Tabular Data</em></a>,
      as defined in&nbsp;[[!tabular-data-model]], does not have any <a title="name">column names</a>, only raw data in terms of 
      <a title="row">data rows</a>. In that case, for the purpose of this section, processing begins by (virtually) providing metadata of the 
      format:</p>

      <pre>[{
  "@id": "<em>URI of the CSV file</em>",
  "columns": [{
    "name": "col_1",
   }, 
   {
    "name": "col_2",
   }, 
   .
   .
   .
   {
    "name": "col_k",
  }]
}]</pre>
      <p>Where "k" is the number of columns in the table. The tabular data is then processed as Annotated Tabular Data with 
      this associated metadata, as described in the <a href="#processing-tabular">previous section</a>.</p> 

    </section>



    <section id="examples-1">
    <h2>Examples</h2>

    <p>Let us consider the following example</p>

    <pre class="example" id="csv-example-core" title="CSV input">1,ADDISON AV,Celtis australis,Large Tree Routine Prune,10/18/2010
2,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
3,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
</pre>

    <p>this is a tabular data without any header row; the generated RDF (in Turtle[[!turtle]]) is:</p>
        <pre class="example" title="Turtle output">@prefix : &lt;http://www.example.org/file.csv#&gt; .
@prefix csvw: &lt;http://www.w3.org/ns/csvw#&gt; .
[ csvw:row 1 ;
  :col_1 "1";
  :col_2 "ADDISON AV";
  :col_3 "Celtis australis";
  :col_4 "Large Tree Routine Prune";
  :col_5 "10/18/2010"
] .
[ csvw:row 2 ;
  :col_1 "2";
  :col_2 "EMERSON ST";
  :col_3 "Liquidambar styraciflua";
  :col_4 "Large Tree Routine Prune";
  :col_5 "6/2/2010"
] .
[ csvw:row 3 ;
  :col_1 "3";
  :col_2 "EMERSON ST";
  :col_3 "Liquidambar styraciflua";
  :col_4 "Large Tree Routine Prune";
  :col_5 "6/2/2010"
] .
</pre>

  <p>By adding a <a>header row</a> the data may be as follows:</p>

    <pre class="example" id="csv-example" title="CSV input">GID,On Street,Species,Trim Cycle,Inventory Date
1,ADDISON AV,Celtis australis,Large Tree Routine Prune,10/18/2010
2,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
3,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
        </pre>

        <p>yielding the following RDF:</p>
        <pre class="example" title="Turtle output">@prefix : &lt;http://www.example.org/file.csv#&gt; .
@prefix csvw: &lt;http://www.w3.org/ns/csvw#&gt; .
[ csvw:row 2 ;
  :GID "1";
  :On%20Street "ADDISON AV";
  :Species "Celtis australis";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "10/18/2010"
] .
[ csvw:row 3 ;
  :GID "2";
  :On%20Street "EMERSON ST";
  :Species "Liquidambar styraciflua";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "6/2/2010"
] .
[ csvw:row 4 ;
  :GID "3";
  :On%20Street "EMERSON ST";
  :Species "Liquidambar styraciflua";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "6/2/2010"
] .
</pre>


    <p>The CSV Data may also have the following associated metadata:</p>

    <pre class="example" title="CSV metadata">[{
  "@id": "http://www.example.org/tree-ops.csv",
  "@type": "Table",
  "title": "Tree Operations",
  "keywords": ["tree", "street", "maintenance"],
  "license": "http://opendefinition.org/licenses/cc-by/",
  "modified": "2010-12-31",
  "columns": [{
    "name": "GID",
    "type": "integer"
   }, {
    "name": "On Street",
    "description": "The street that the tree is on.",
    "type": "string"
  }, {
    "name": "Species",
    "description": "The species of the tree.",
    "type": "string"
  }, {
    "name": "Trim Cycle",
    "description": "The operation performed on the tree.",
    "type": "string"
  }, {
    "name": "Inventory Date",
    "description": "The date of the operation that was performed.",
    "type": "date",
    "format": "M/D/YYYY"
  }]
  "primaryKey": "_:GID"  
}]</pre>

        <p>The generated RDF is then:</p>
<pre class="example" title="Turtle output">
@prefix csvw: &lt;http://www.w3.org/ns/csvw#> .
@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#> .
@prefix dc:   &lt;http://purl.org/dc/terms/> .
@prefix id:   &lt;http://www.example.org/tree-ops.csv#> .

id: 
  a id:Table,
  dc:title "Tree Operations";
  dc:license &lt;http://opendefinition.org/licenses/cc-by/>;
  dc:modified "2010-12-31" .

id:1 
  csvw:row 2 ;
  :GID 1;
  :On%20Street "ADDISON AV";
  :Species "Celtis australis";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "2010-10-18"^^xsd:date
.
id:2
  csvw:row 3 ;
  :GID 2;
  :On%20Street "EMERSON ST";
  :Species "Liquidambar styraciflua";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "2010-6-2"^^xsd:date
.
id:3 
  csvw:row 4 ;
  :GID 3;
  :On%20Street "EMERSON ST";
  :Species "Liquidambar styraciflua";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "2010-6-20"^^xsd:date
.
</pre>
        <p>Note the value for <code>:GID</code> is now an integer, and the value for <code>:Inventory%20Date</code> is a proper date.</p>

        <p class="TBD">More examples should be added here</p>

    </section>
    <section id="templates">
      <h2>Templates</h2>
      <p class="TBD">This section may have to be re-worked, made it generic, possibly moved
        to another document</p>
      <section id="graph-template">
        <h2>Graph Templates</h2>
        <p>An RDF graph can be used as a template for mapping fields from a row
          by following a couple of conventions.</p>
        <ul>
          <li>A literal may be composed of one or more <a title="field reference">Field
              References</a>.</li>
          <li>A URI may be composed of one or more <a title="field reference">Field
              References</a>.</li>
        </ul>
        <p>A graph template is defined (as a named graph?) within a metadata
          mapping file as set of RDF triples where any value may include one or
          more <a title="field reference">Field References</a>. Each record is
          processed to emit triples based on transforming the graph template
          into a series of triples created from the result of substiting <a title="field reference">Field
            References</a> for their referenced field values. Triples which
          result in any position having a value of <code>csv:nil</code> are
          excluded from output. </p>
        <section id="field-references">
          <h3>Field References</h3>
          <p>A <dfn>Field Reference</dfn> is a brace-surrounded value matching
            a <a title="name">column name</a> from the CSV input. During record expansion, <a
              title="field reference">field references</a> are replaced with the
            value of the field from the specific record being mapped.</p>
          <pre class="example" title="Field Reference">          [
          schema:name "{name}"@en;
          schema:homepage &lt;{+homepage}&gt;;
          schema:image &lt;{+image}&gt;
          ] .
        </pre>
          <p>Given an input file such as the following:</p>
          <table>
            <tbody>
              <tr>
                <th>name</th>
                <th>homepage</th>
                <th>image</th>
              </tr>
              <tr>
                <td>Homer Simpson</td>
                <td>http://example/homer</td>
                <td>http://example/avatar/homer.png</td>
              </tr>
            </tbody>
          </table>
          <p>The resulting output graph would be the following:</p>
          <pre class="example" title="Field Reference Result">          [
            schema:name "Homer Simpson"@en;
            schema:homepage &lt;http://example/homer&gt;;
            schema:image &lt;http://example/avatar/homer.png&gt;
          ] .
        </pre>
        </section>




        <section id="uri-templates">
          <h3>URI Templates</h3>
          <p>A URI Template is a URI containing one or more variables as
            described in [[!RFC6570]]. URI variables are treated as <a title="field reference">Field
              References</a>. The expansion of URI Templates is modified so that
            if the URI template contains any unmapped <a>Field Reference</a>
            the resulting URI is replaced with <code>csv:nil</code>. After
            processing, all triples containing <code>csv:nil</code> in any
            position are removed.</p>
          <p>A URI template having the scheme "_" (otherwise illegal) results in
            a blank node if all <a>Field References</a>
            are substituted.</p>
          <p>{COL} value </p>
          <p>Lookup </p>
          <p>String functions (SPARQL? i.e. XSD functions and operators) </p>
        </section>
      </section>
    </section>
    <section id="csv-ld">
      <h2>CSV-LD</h2>
      <p> A further procedure mapping to JSON-LD. </p>
      <div class="issue">Better as a separate document?</div>
    </section>
  </body>
</html>
