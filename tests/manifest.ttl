# CSV+ tests
## Distributed under both the W3C Test Suite License[1] and the W3C 3-
## clause BSD License[2]. To contribute to a W3C Test Suite, see the
## policies and contribution forms [3]
##
## 1. http://www.w3.org/Consortium/Legal/2008/04-testsuite-license
## 2. http://www.w3.org/Consortium/Legal/2008/03-bsd-license
## 3. http://www.w3.org/2004/10/27-testcases
##
## Test types (for now)
## * CsvToJsonTest  - tests CSV evaluation to JSON
## * CsvToRdfTest   - tests CSV evaluation to RDF using graph isomorphism
## * CsvSparqlTest - tests CSV evaulation to RDF using SPARQL ASK query

@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mf:   <http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#> .
@prefix csvt: <http://w3c.github.io/csvw/tests/vocab#> .

<>  a mf:Manifest ;
    mf:name "CSV+ tests" ;
    mf:entries (
      # Right now, just syntax tests; later, replicate for different transformations
      <test001j>
      <test001r>
      <test002j>
      <test002r>
      <test003j>
      <test003r>
      <test005j>
      <test005r>
      <test006j>
      <test006r>
      <test007j>
      <test007r>
      <test008j>
      <test008r>
      <test009j>
      <test009r>
      <test010j>
      <test010r>
      <test011j>
      <test011r>
      <test012j>
      <test012r>
      <test012mj>
      <test012mr>
      <test013j>
      <test013r>
      <test014j>
      <test014r>
      <test015j>
      <test015r>
      <test016j>
      <test016r>
      <test017j>
      <test017r>
      <test018j>
      <test018r>
      <test019j>
      <test019r>
      <test020j>
      <test020r>
      <test021j>
      <test021r>
      <test022j>
      <test022r>
    ) .

<test001j> a csvt:CsvToJsonTest;
  mf:name       "Simple table (json)";
  rdfs:comment  "The simplest possible table without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test001.csv>;
  mf:result     <test001.json>;
  .

<test001r> a csvt:CsvToRdfTest;
  mf:name       "Simple table (rdf)";
  rdfs:comment  "The simplest possible table without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test001.csv>;
  mf:result     <test001.ttl>;
  .

<test002j> a csvt:CsvToJsonTest;
  mf:name       "quoted field (json)";
  rdfs:comment  "Table with one quoted field without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test002.csv>;
  mf:result     <test002.json>;
  .

<test002r> a csvt:CsvToRdfTest;
  mf:name       "quoted field (rdf)";
  rdfs:comment  "Table with one quoted field without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test002.csv>;
  mf:result     <test002.ttl>;
  .

<test003j> a csvt:CsvToJsonTest;
  mf:name       "Surrounding spaces (json)";
  rdfs:comment  "Table with whitespace before and after every field without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test003.csv>;
  mf:result     <test003.json>;
  .

<test003r> a csvt:CsvToRdfTest;
  mf:name       "Surrounding spaces (rdf)";
  rdfs:comment  "Table with whitespace before and after every field without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test003.csv>;
  mf:result     <test003.ttl>;
  .

<test005j> a csvt:CsvToJsonTest;
  mf:name       "Identifier references (json)";
  rdfs:comment  "A table with entity identifiers and references to other entities without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test005.csv>;
  mf:result     <test005.json>;
  .

<test005r> a csvt:CsvToRdfTest;
  mf:name       "Identifier references (rdf)";
  rdfs:comment  "A table with entity identifiers and references to other entities without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test005.csv>;
  mf:result     <test005.ttl>;
  .

<test006j> a csvt:CsvToJsonTest;
  mf:name       "No identifiers (json)";
  rdfs:comment  "Records contain two entities with relationships which are duplicated without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test006.csv>;
  mf:result     <test006.json>;
  .

<test006r> a csvt:CsvToRdfTest;
  mf:name       "No identifiers (rdf)";
  rdfs:comment  "Records contain two entities with relationships which are duplicated without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test006.csv>;
  mf:result     <test006.ttl>;
  .

<test007j> a csvt:CsvToJsonTest;
  mf:name       "Joined table with unique identifiers (json)";
  rdfs:comment  "Joined data with identified records without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test007.csv>;
  mf:result     <test007.json>;
  .

<test007r> a csvt:CsvToRdfTest;
  mf:name       "Joined table with unique identifiers (rdf)";
  rdfs:comment  "Joined data with identified records without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test007.csv>;
  mf:result     <test007.ttl>;
  .

<test008j> a csvt:CsvToJsonTest;
  mf:name       "Microsyntax - internal field separator (json)";
  rdfs:comment  "One field has comma-separated values without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test008.csv>;
  mf:result     <test008.json>;
  .

<test008r> a csvt:CsvToRdfTest;
  mf:name       "Microsyntax - internal field separator (rdf)";
  rdfs:comment  "One field has comma-separated values without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test008.csv>;
  mf:result     <test008.ttl>;
  .

<test009j> a csvt:CsvToJsonTest;
  mf:name       "Microsyntax - formatted time (json)";
  rdfs:comment  "Field with parseable human formatted time without metadata";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test009.csv>;
  mf:result     <test009.json>;
  .

<test009r> a csvt:CsvToRdfTest;
  mf:name       "Microsyntax - formatted time (rdf)";
  rdfs:comment  "Field with parseable human formatted time without metadata";
  csvt:approval csvt:Proposed;
  mf:action     <test009.csv>;
  csvt:option   [csvt:noProv true];
  mf:result     <test009.ttl>;
  .

<test010j> a csvt:CsvToJsonTest;
  mf:name       "Country-codes-and-names example (json)";
  rdfs:comment  "Country Codes and Names example";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test010.csv>;
  mf:result     <test010.json>;
  .

<test010r> a csvt:CsvToRdfTest;
  mf:name       "Country-codes-and-names example (rdf)";
  rdfs:comment  "Country Codes and Names example";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test010.csv>;
  mf:result     <test010.ttl>;
  .

<test011j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with metadata (json)";
  rdfs:comment  "tree-ops example with metadata. Processors should load metadata based on action URL.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test011.csv>;
  csvt:implicit <test011.csv-metadata.json>;
  mf:result     <test011.json>;
  .

<test011r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with metadata (rdf)";
  rdfs:comment  "tree-ops example with metadata. Processors should load metadata based on action URL.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test011.csv>;
  csvt:implicit <test011.csv-metadata.json>;
  mf:result     <test011.ttl>;
  .

<test012j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with directory metadata (json)";
  rdfs:comment  "tree-ops example with directory metadata. Processors should find directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test012/action.csv>;
  csvt:implicit <test012/metadata.json>;
  mf:result     <test012/result.json>;
  .

<test012r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with directory metadata (rdf)";
  rdfs:comment  "tree-ops example with directory metadata. Processors should find directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test012/action.csv>;
  csvt:implicit <test012/metadata.json>;
  mf:result     <test012/result.ttl>;
  .

<test012mj> a csvt:MetadataToJsonTest;
  mf:name       "tree-ops example from directory metadata (json)";
  rdfs:comment  "tree-ops example from directory metadata. Processors should find CSV from metadata action file.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test012/metadata.json>;
  csvt:implicit <test012/action.csv>;
  mf:result     <test012/result.json>;
  .

<test012mr> a csvt:MetadataToRdfTest;
  mf:name       "tree-ops example from directory metadata (rdf)";
  rdfs:comment  "tree-ops example from directory metadata. Processors should find CSV from metadata action file.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test012/metadata.json>;
  csvt:implicit <test012/action.csv>;
  mf:result     <test012/result.ttl>;
  .

<test013j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with user-specified metadata (json)";
  rdfs:comment  "tree-ops example with user-specified metadata. Processors load user-specified metadata before CSV.";
  csvt:approval csvt:Proposed;
  csvt:option   [
    csvt:noProv true;
    csvt:metadata <test013-user-metadata.json>;
  ];
  mf:action     <test013.csv>;
  csvt:implicit <test013-user-metadata.json>;
  mf:result     <test013.json>;
  .

<test013r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with user-specified metadata (rdf)";
  rdfs:comment  "tree-ops example with user-specified metadata. Processors load user-specified metadata before CSV.";
  csvt:approval csvt:Proposed;
  csvt:option   [
    csvt:noProv true;
    csvt:metadata <test013-user-metadata.json>;
  ];
  mf:action     <test013.csv>;
  csvt:implicit <test013-user-metadata.json>;
  mf:result     <test013.ttl>;
  .

<test014j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with linked metadata (json)";
  rdfs:comment  "tree-ops example with linked metadata. Processors load metadata from link header.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  csvt:httpLink "<test014-linked-metadata.json>; rel=\"describedby\"";
  mf:action     <test014.csv>;
  csvt:implicit <test014-linked-metadata.json>;
  mf:result     <test014.json>;
  .

<test014r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with linked metadata (rdf)";
  rdfs:comment  "tree-ops example with linked metadata. Processors load metadata from link header.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  csvt:httpLink "<test014-linked-metadata.json>; rel=\"describedby\"";
  mf:action     <test014.csv>;
  csvt:implicit <test014-linked-metadata.json>;
  mf:result     <test014.ttl>;
  .

<test015j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with user and directory metadata (json)";
  rdfs:comment  "tree-ops example with user and directory metadata. Processors should find directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [
    csvt:noProv true;
    csvt:metadata <test015/user-metadata.json>
    ];
  mf:action     <test015/action.csv>;
  csvt:implicit <test015/user-metadata.json>, <test015/metadata.json>;
  mf:result     <test015/result.json>;
  .

<test015r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with user and directory metadata (rdf)";
  rdfs:comment  "tree-ops example with user and directory metadata. Processors should find directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [
    csvt:noProv true;
    csvt:metadata <test015/user-metadata.json>;
  ];
  mf:action     <test015/action.csv>;
  csvt:implicit <test015/user-metadata.json>, <test015/metadata.json>;
  mf:result     <test015/result.ttl>;
  .

<test016j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with linked and directory metadata (json)";
  rdfs:comment  "tree-ops example with linked and directory metadata. Processors should find link- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test016/action.csv>;
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  csvt:implicit <test016/linked-metadata.json>, <test016/metadata.json>;
  mf:result     <test016/result.json>;
  .

<test016r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with linked and directory metadata (rdf)";
  rdfs:comment  "tree-ops example with linked and directory metadata. Processors should find link- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  mf:action     <test016/action.csv>;
  csvt:implicit <test016/linked-metadata.json>, <test016/metadata.json>;
  mf:result     <test016/result.ttl>;
  .

<test017j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with file and directory metadata (json)";
  rdfs:comment  "tree-ops example with file and directory metadata. Processors should find file- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test017/action.csv>;
  csvt:implicit <test017/action.csv-metadata.json>, <test017/metadata.json>;
  mf:result     <test017/result.json>;
  .

<test017r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with file and directory metadata (rdf)";
  rdfs:comment  "tree-ops example with file and directory metadata. Processors should find file- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test017/action.csv>;
  csvt:implicit <test017/action.csv-metadata.json>, <test017/metadata.json>;
  mf:result     <test017/result.ttl>;
  .

<test018j> a csvt:CsvToJsonTest;
  mf:name       "tree-ops example with file and directory metadata (json)";
  rdfs:comment  "tree-ops example with file and directory metadata. Processors should find file- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:option   [
    csvt:noProv true;
    csvt:metadata <test018/user-metadata.json>;
  ];
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  mf:action     <test018/action.csv>;
  csvt:implicit <test018/user-metadata.json>, <test018/linked-metadata.json>, <test018/action.csv-metadata.json>, <test018/metadata.json>;
  mf:result     <test018/result.json>;
  .

<test018r> a csvt:CsvToRdfTest;
  mf:name       "tree-ops example with file and directory metadata (rdf)";
  rdfs:comment  "tree-ops example with file and directory metadata. Processors should find file- and directory-based metadata.";
  csvt:approval csvt:Proposed;
  csvt:httpLink "<linked-metadata.json>; rel=\"describedby\"";
  csvt:option   [
    csvt:noProv true;
    csvt:metadata <test018/user-metadata.json>;
  ];
  mf:action     <test018/action.csv>;
  csvt:implicit <test018/user-metadata.json>, <test018/linked-metadata.json>, <test018/action.csv-metadata.json>, <test018/metadata.json>;
  mf:result     <test018/result.ttl>;
  .

<test019j> a csvt:CsvToJsonTest;
  mf:name       "no header (json)";
  rdfs:comment  "If a CSV+ file does not include a header line, this MUST be specified using the header parameter.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  csvt:contentType "text/csv;header=absent";
  mf:action     <test019.csv>;
  mf:result     <test019.json>;
  .

<test019r> a csvt:CsvToRdfTest;
  mf:name       "no header (rdf)";
  rdfs:comment  "If a CSV+ file does not include a header line, this MUST be specified using the header parameter.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  csvt:contentType "text/csv;header=absent";
  mf:action     <test019.csv>;
  mf:result     <test019.ttl>;
  .

<test020j> a csvt:CsvToJsonTest;
  mf:name       "trim=start (json)";
  rdfs:comment  "If trim is true or start then whitespace from the start of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test020.csv>;
  csvt:implicit <test020.csv-metadata.json>;
  mf:result     <test020.json>;
  .

<test020r> a csvt:CsvToRdfTest;
  mf:name       "trim=start (rdf)";
  rdfs:comment  "If trim is true or start then whitespace from the start of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test020.csv>;
  csvt:implicit <test020.csv-metadata.json>;
  mf:result     <test020.ttl>;
  .

<test021j> a csvt:CsvToJsonTest;
  mf:name       "trim=end (json)";
  rdfs:comment  "If trim is true or end then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test021.csv>;
  csvt:implicit <test021.csv-metadata.json>;
  mf:result     <test021.json>;
  .

<test021r> a csvt:CsvToRdfTest;
  mf:name       "trim=end (rdf)";
  rdfs:comment  "If trim is true or end then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test021.csv>;
  csvt:implicit <test021.csv-metadata.json>;
  mf:result     <test021.ttl>;
  .

<test022j> a csvt:CsvToJsonTest;
  mf:name       "trim=true (json)";
  rdfs:comment  "If trim is true or start then whitespace from the start of values that are not enclosed MUST be removed from the value. If trim is true or end then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test022.csv>;
  csvt:implicit <test022.csv-metadata.json>;
  mf:result     <test022.json>;
  .

<test022r> a csvt:CsvToRdfTest;
  mf:name       "trim=true (rdf)";
  rdfs:comment  "If trim is true or start then whitespace from the start of values that are not enclosed MUST be removed from the value. If trim is true or end then whitespace from the end of values that are not enclosed MUST be removed from the value.";
  csvt:approval csvt:Proposed;
  csvt:option   [csvt:noProv true];
  mf:action     <test022.csv>;
  csvt:implicit <test022.csv-metadata.json>;
  mf:result     <test022.ttl>;
  .

