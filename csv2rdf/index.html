<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Generating RDF from Web Tabular Data</title>
    <script class="remove" src="http://www.w3.org/Tools/respec/respec-w3c-common">
	  </script>
    <script class="remove">
var respecConfig = {
    // localBiblio: {
    //     "EBNF-NOTATION": "Tim Bray; Jean Paoli; C. M. Sperberg-McQueen; Eve Maler; Fran√ßois Yergeau. <a href=\"http://www.w3.org/TR/REC-xml/#sec-notation\"><cite>EBNF Notation</cite></a> 26 November 2008. W3C Recommendation. URL: <a href=\"http://www.w3.org/TR/REC-xml/#sec-notation\">http://www.w3.org/TR/REC-xml/#sec-notation</a>"
    // },
    specStatus: "ED",
    shortName: "csv2rdf",
    publishDate:  "2014-04-01",
    previousPublishDate: "2014-??-??",
    previousMaturity: "unoffical",
    //previousURI: "http://www.w3.org/TR/2014/WD-csv2rdf-2014????/",
    edDraftURI: "http://w3c.github.io/csvw/csv2rdf/",
    // lcEnd: "3000-01-01",
    // crEnd: "3000-01-01",
    editors:
     [{
       name: "Andy Seaborne"
       , company: "Apache Software Foundation"
       , companyURL: ""
    // }, { 
    //   name: "Gregg Kellogg", 
    //   url: "http://greggkellogg.net/",
    //   company: "Kellogg Associates", 
    //   companyURL: "http://kellogg-assoc.com/" 
    }],
    wg: "CSV on the Web Working Group",
    wgURI: "http://www.w3.org/2013/csvw/",
    wgPublicList: "public-csv-wg",
    wgPatentURI: "http://www.w3.org/2004/01/pp-impl/68238/status",
    otherLinks: [{
      key: "Repository",
      data: [{
          value: "We are on Github",
          href: "https://github.com/w3c/csv2rdf"
        }, {
          value: "File a bug",
          href: "https://github.com/w3c/csv2rdf"
        }]
      } , 
      {
        key: "Changes",
        data: [{
        //     value: "Diff to previous version",
        //     href: "diff-20140327.html"
        //   }, {}
           value: "Commit history",
           href: "https://github.com/w3c/csvw/commits/gh-pages"
         }]
       }] ,
    inlineCSS: true,
    noIDLIn: true,
    noLegacyStyle: false
    };
    </script>
    <style type="text/css">
      .grammar td { font-family: monospace; vertical-align: top; }
      .grammar-literal { color: gray;}
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
      <a href="http://www.w3.org/TR/tabular-data-model/"
      >Model for Tabular Data and Metadata on the Web</a>
      </p><p>
        Tabular data is routinely transferred on the web as "CSV".
      </p>
    </section>
    <section id="sotd">
      <p>
        Work-in-progress. 
      </p>
    </section>

    <section id="intro">
      <h2>Introduction</h2>
      <p>
        This document uses keywords from 
        <a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>
        and
        <a href="https://tools.ietf.org/html/rfc6919">RFC6919</a>.
      </p>
      <p>
        <dfn title="tabular data">Tabular data</dfn> is data that is structured into rows, each of which contains information about some thing. Each row contains the same number of fields (although some of these fields may be empty), which provide values of properties of the thing described by the row. In tabular data, fields within the same column provide values for the same property of the thing described by the particular row. This is what differentiates tabular data from other line-oriented formats. 
      </p>
      <p>
        CSV RFC [[!RFC4180]] (to be revised).
      </p>

      <p>The input to the conversion is Tabular data. Exact details of translating the many 
        existing tabular data forms.
      </p>

      <p>
        There are 3 different level of conversion, increasing levels of facilities:
      </p>

      <ul>
        <li>Column mapping - each column is a predicate or a key.  Each
          field in a predicate column is converted to an RDF triples.  A key, if
          present, provides the subject of the triples for a row.
        </li>
        <li>?? Mapping</li>
        <li>CSV-LD for JSON-LD</li>
      </ul>
    </section>

    <section id="examples">
      <h2>Examples</h2>
        
      <section>
        <h3>Example 1</h3>
        <pre>GID,On Street,Species,Trim Cycle,Inventory Date
1,ADDISON AV,Celtis australis,Large Tree Routine Prune,10/18/2010
2,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
3,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
        </pre>
        <p>gives the following RDF (in Turtle) for the data rows.</p>
        <pre>
# Data rows
[ csv:row 2 ;
  :GID 1;
  :On%20Street "ADDISON AV";
  :Species "Celtis australis";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "10/18/2010"
] .
[ csv:row 3 ;
  :GID 2;
  :On%20Street "EMERSON ST";
  :Species "Liquidambar styraciflua";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "6/2/2010"
] .
[ csv:row 4 ;
  :GID 3;
  :On%20Street "EMERSON ST";
  :Species "Liquidambar styraciflua";
  :Trim%20Cycle "Large Tree Routine Prune";
  :Inventory%20Date "6/2/2010"
] .
</pre>
        <p>In the full Column Mapping, metadata about the translation
            applied is also included.
        </p>
          
      </section>
    </section>

    <section id="basic-mapping">
      <h2>Basic Mapping</h2>

      <small>
        <p>Previous description for just the column mapping: 
          <a href="https://www.w3.org/2013/csvw/wiki/CSV2RDF">CSV2RDF on the WG wiki</a>
        </p>
      </small>

      <p>
        In basic mapping, a process is applied to the CSV data that
        takes each row in the input tabular data and emits a number for triples 
        translated to a number of triples, which with the same subject. 
        In addition, some table-wide RDF triples can also be added to the output.
      </p>

      <section id="annotations">
        <h3>Annotations</h3>
        <p>Possible annotations.</p>
        <section id="annotation-table">
          <h4>Table</h4>
          <ul>
            <li>Base URI
            </li>
            <li>General information about the table
              (title, source, publication date, provenance,...)
            </li>
          </ul>
        </section>

        <section id="annotation-row">
          <h4>Row</h4>
          <ul>
            <li>A template for generating a subject URI.
              {COL} for value of a column.
              (implies a default of "skip" on any column used.)
            </li>
            <li>Identify a column as a key, which together with a a URI
              template, generates the subject used for triples for each row.
            </li>
            <li>rdf:type for each row (URI template?)
            </li>
          </ul>
        </section>

        <section id="annotation-column">
          <h4>Column Annotations</h4>
          <ul>
            <li>Predicate for this column. Default to <tt>base:colname</tt> 
              for sanitized <tt>colname</tt>.
            </li>
            <li>Datatypes for fields in the column. </li>
            <li>skip - do not generate triples for this column (value maybe used in templates).</li>
            <li>guess datatype</li>
            <li>language tag</li>
            <li>URI template</li>
            <li>RDF template (path + bNodes is a special case of an RDF template).</li>
            <li>Lexical form templates</li>
            <li>whilespace handling (trim, trim left, trim right, none)</li>
            <li>Empty field handling (yes, skip, default value?)</li>
            <li>Default values, and explciit "null" e.g. ("N/A", -999)</li>
          </ul>
          <p>conditional forms? "skip if blank else ..."</p>
        </section>
      </section>

      <section id="uri-templates">
        <h3>URI Templates</h3>
        <p>{COL} value
        </p>
        <p>Lookup
        </p>
        <p>String functions (SPARQL? i.e. XSD functions and operators)
        </p>
      </section>

      <section id="datatype-inspection">
        <h3>Datatype by Appearance</h3>
        <p>If guessing datatypes:
        </p>
        <ul>
          <li>Numbers: integer, decimal or double
          </li>
          <li>Boolean
          </li>
          <li>http: URIs.  Other? mailto:? urn:?
          </li>
        </ul>
        <p>otherwise the field value is processed as a string.
        </p>
      </section>

      <section id="mapping-outline">
        <h3>Outline of the Mapping Process</h3>
        <p>The process takes places in the following steps:
        </p>
        <ul>
          <li>Table-level Generation
          </li>
          <li>Determine Column Translations.
          </li>
        </ul>
<pre>
For each row:
  Subject is template or bnode
  For each filed in the row:
    Predicate is column predicate
    If skip, skip.
    If a datatype is given :dt, the object is "string"^^:dt
    If a language tag is given @tag, the object is "string"@tag
    If a URI template is given ...
    If guess, guess integer/decimal/double/boolean/http URI (URN?)
    ...
    Else xsd:string
    Emit (s,p,o)
</pre>
      </section>

      <section id="data-conversion">
        <h3>Data Conversion</h3>
        <p>More details on guessing datatypes.</p>
      </section>

      <section id="minimal-mapping">
        <h3>Minimal Mapping</h3>
        <p>If there is no header row and no annotations, then a fixed process is applied to
          generate sufficient annotations to generate output.  A header row is
          assumed with column names <tt>"col1", "col2", ....</tt>; the fields of a CSV record
          (row) are inspected to determine whether to generate numbers, booleans, links or strings
          by inspecting the character value of a field.  Fields have whiste space trimmed.
        </p>
      </section>
    </section>

    <section> <!-- id = ?? -->
      <h2>Further Mapping</h2>
      <small><i>
      <p>By applying multiple conversions, with different setups, 
      you can do some quite complicated things.
      </p>

      <p>Multiple templates producing different output over multiple passes (or in parallel).</p>
      <p>"URI overlap" - intentional same URI between between conversions
      leads to RDF that is not merely a reflection of the table.
      </p>
      <p>
        Add skipping rows on a condition (e.g. field blank)
      </p>
      </i></small>

      <p>
        In this section, we describe mapping that goes beyond the 
        column mapping described above.  The RDF triples may not correspond
        simply to the rows of the input Annotated Tabular Data Model.
      </p>
      <div class="issue">Multi-table?</div>
      <div class="issue">Schema-driven, schema-influenced conversion</div>
    </section>

    <section id="csv-ld">
      <h2>CSV-LD</h2>
      <p>
        A further procedure mapping to JSON-LD.
      </p>

      <div class="issue">Better as a separate document?</div>

    </section>

  </body>
</html>

